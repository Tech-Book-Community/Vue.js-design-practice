---
layout: center
class: text-center
glowSeed: 330
---

<h1 class="tagline !text-3em !leading-normal font-500">第 9 章 & 第 10 章</h1>

簡單 Diff 演算法 & 雙端 Diff 演算法

<!--
大家好，今天我們要來聊第 9 章和第 10 章：簡單 Diff 演算法和雙端 Diff 演算法。
-->

---
layout: center
---

# 還記得第一章的公式嗎？

<div v-click mt-8>

<div text-center text-2xl leading-relaxed>
<span text-yellow-300 font-bold>聲明式的更新性能消耗</span>
<span mx-3>=</span>
<span text-red-300 font-bold>找出差異的性能消耗</span>
<span mx-3>+</span>
<span text-green-300 font-bold>直接修改的性能消耗</span>
</div>

</div>

<!--
在開始之前，我們先回顧一下第一章提到的這個核心公式。

[點擊] 聲明式的更新性能消耗，等於「找出差異的性能消耗」加上「直接修改的性能消耗」。
-->

---
layout: center
---

# 聲明式永遠無法超越命令式？

<div v-click mt-8 text-xl text-gray-300>
聲明式程式碼的效能理論上不可能超越命令式程式碼<br>
因為它多了「找出差異」這一步
</div>

<div v-click mt-8>

<div class="px-8 py-6 bg-blue-900/20 border-2 border-blue-500/40 rounded-lg inline-block">
<div text-2xl text-blue-300>
但是，如果我們能夠 <span text-yellow-300 font-bold>最小化找出差異的效能消耗</span>
</div>
<div text-2xl text-blue-300 mt-2>
就可以讓聲明式程式碼的效能 <span text-green-300 font-bold>無限接近</span> 命令式程式碼
</div>
</div>

</div>

<!--
當時我們說，聲明式程式碼的效能理論上不可能超越命令式程式碼，因為它多了「找出差異」這一步。

[點擊] 但是，虛擬 DOM 的核心目標，就是要最小化這個「找出差異」的成本。
如果我們能夠最小化找出差異的效能消耗，就可以讓聲明式程式碼的效能無限接近命令式程式碼。
-->

---
layout: center
---

<div flex items-center justify-center gap-12>
  <div i-carbon-compare text-8xl text-purple-400 />
  <div>
    <h1>Diff 演算法</h1>
    <div text-2xl text-gray-300 mt-4>尋找差異的演算法</div>
  </div>
</div>

<div v-click mt-12 text-center text-xl text-yellow-300>
它直接決定了 Vue 的效能上限
</div>

<!--
而尋找差異的演算法，就叫做 Diff 演算法。

[點擊] 這也是為什麼 Diff 演算法如此重要——它直接決定了 Vue 的效能上限。
-->

---
layout: center
---

# Diff 演算法要解決什麼問題？

<div v-click mt-8 text-xl text-gray-300>
在渲染器中，當新舊虛擬節點的子節點都是一組節點時<br>
我們需要對比這兩組子節點，找出它們的差異並更新
</div>

<!--
那 Diff 演算法具體要解決什麼問題呢？

[點擊] 在渲染器中，當新舊虛擬節點的子節點都是一組節點時，我們需要對比這兩組子節點，找出它們的差異並更新。
-->

---

# 舉個例子

<div grid grid-cols-2 gap-12 mt-8>
  <div v-click="1">
    <div text-xl font-bold mb-4 text-blue-300>
      舊的虛擬節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{
  type: 'div',
  children: [
    { type: 'p', children: '1' },
    { type: 'p', children: '2' },
    { type: 'p', children: '3' }
  ]
}
```
    </div>
  </div>

  <div v-click="2">
    <div text-xl font-bold mb-4 text-green-300>
      新的虛擬節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{
  type: 'div',
  children: [
    { type: 'p', children: '4' },
    { type: 'p', children: '5' },
    { type: 'p', children: '6' }
  ]
}
```
    </div>
  </div>
</div>

<!--
我們來看一個具體的例子：

[點擊] 假設我們有舊的虛擬節點，有三個 p 標籤作為子節點，內容分別是 1、2、3。

[點擊] 新的虛擬節點也是三個 p 標籤，但內容變成了 4、5、6。
-->

---

# 回顧第 8 章：最簡單但最慢的做法

<div v-click="1" mt-8>

**卸載所有舊子節點 → 掛載所有新子節點**

<div class="bg-gray-800/50 rounded-lg p-4 mt-4">

```js
function patchChildren(n1, n2, container) {
  // 卸載所有舊子節點
  if (Array.isArray(n1.children)) {
    n1.children.forEach(c => unmount(c))
  }

  // 掛載所有新子節點
  if (Array.isArray(n2.children)) {
    n2.children.forEach(c => patch(null, c, container))
  }
}
```

</div>

</div>

<!--
[點擊] 回顧一下第 8 章，我們處理子節點更新時採用了最直接的方式：
卸載所有舊子節點，然後掛載所有新子節點。
-->

---

# 這個做法的問題是什麼？

<div v-click="1" mt-8>

<div class="px-8 py-6 bg-red-900/20 border-2 border-red-500/40 rounded-lg inline-block">
<div text-3xl text-red-300 font-bold>
❌ 沒有復用任何 DOM 元素！
</div>
</div>

</div>

<div v-click="2" mt-8 text-xl>

對於上面的例子：
- 卸載 3 個 `<p>` 標籤 = **3 次 DOM 刪除操作**
- 掛載 3 個 `<p>` 標籤 = **3 次 DOM 添加操作**
- <span text-red-400 font-bold text-2xl>總共：6 次 DOM 操作</span>

</div>

<!--
這個做法的問題是什麼？

[點擊] 沒有復用任何 DOM 元素！

[點擊] 把舊的全部卸載需要 3 次刪除操作，再把新的全部掛載需要 3 次添加操作，總共 6 次 DOM 操作。
-->

---
layout: center
---

# 但這真的是最好的方案嗎？ 🤔

---
layout: center
---

# 仔細觀察

<div v-click text-4xl text-center leading-relaxed mt-12>
標籤類型都是 <code class="bg-blue-500/20 px-4 py-2 rounded text-blue-300 text-5xl">p</code>
</div>

<div v-click text-4xl text-center mt-8>
只有 <span text-green-400 font-bold>文字內容</span> 不同
</div>

<!--
我們仔細觀察一下，會發現一個關鍵：

[點擊] 新舊兩組子節點的標籤類型都是 p，標籤類型完全相同，

[點擊] 只是文字內容不同。

那麼，我們能不能復用這些 DOM 元素呢？
-->

---

# 方案對比

<div grid grid-cols-2 gap-8 mt-8>
  <div class="p-8 bg-red-900/10 rounded-xl">
    <div text-2xl font-bold mb-6 text-red-300 flex items-center>
      <div i-carbon-close mr-3 text-3xl />暴力方案
    </div>
    <div space-y-3 text-lg text-gray-300>
      <div>卸載 3 個舊節點</div>
      <div>掛載 3 個新節點</div>
    </div>
    <div class="mt-6 pt-6 border-t-2 border-red-500/30">
      <div font-bold text-4xl text-center text-red-300>6 次操作</div>
    </div>
  </div>

  <div v-click class="p-8 bg-green-900/10 rounded-xl">
    <div text-2xl font-bold mb-6 text-green-300 flex items-center>
      <div i-carbon-checkmark mr-3 text-3xl />復用方案
    </div>
    <div space-y-3 text-lg text-gray-300>
      <div>復用 3 個 DOM 元素</div>
      <div>更新 3 次文字內容</div>
    </div>
    <div class="mt-6 pt-6 border-t-2 border-green-500/30">
      <div font-bold text-4xl text-center text-green-300>3 次操作</div>
    </div>
  </div>
</div>

<!--
讓我們來對比一下兩種方案：

暴力方案需要 6 次 DOM 操作：卸載 3 個舊節點，掛載 3 個新節點。

[點擊] 復用方案只需要 3 次 DOM 操作：復用 3 個 DOM 元素，更新 3 次文字內容。
-->

---
layout: center
---

<div text-center>

# 這就是 Diff 演算法要做的事情

<div v-click mt-8 text-2xl text-green-300>
找出可以復用的節點<br>
用最少的 DOM 操作完成更新
</div>

</div>

<!--
這就是 Diff 演算法要做的事情：找出可以復用的節點，用最少的 DOM 操作完成更新。
-->

---

# 但問題來了... 🤔

<div mt-12 text-2xl text-gray-300 leading-relaxed>

<div v-click>❓ 我們要怎麼知道哪些節點可以復用？</div>
<div v-click mt-4>❓ 哪些需要移動？</div>
<div v-click mt-4>❓ 哪些需要新增或刪除？</div>

</div>

<div v-click mt-12 flex items-center justify-center>
  <div class="px-12 py-8 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
    <div text-3xl text-purple-300>
      這就需要一個聰明的演算法 💡
    </div>
  </div>
</div>

<!--
但問題來了：

[點擊] 我們要怎麼知道哪些節點可以復用？
[點擊] 哪些需要移動？
[點擊] 哪些需要新增或刪除？

[點擊] 這就需要一個聰明的演算法。
-->

---

# Diff 演算法的核心任務

<div grid grid-cols-3 gap-8 mt-12>
  <div v-click="1" class="border-2 border-purple-500/30 rounded-lg p-8 bg-purple-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-compare text-5xl text-purple-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-purple-300>比較差異</div>
      <div text-lg text-gray-300>對比新舊虛擬節點</div>
    </div>
  </div>

  <div v-click="2" class="border-2 border-blue-500/30 rounded-lg p-8 bg-blue-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-renew text-5xl text-blue-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-blue-300>找出復用</div>
      <div text-lg text-gray-300>標記可復用的節點</div>
    </div>
  </div>

  <div v-click="3" class="border-2 border-green-500/30 rounded-lg p-8 bg-green-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-chip text-5xl text-green-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-green-300>計算操作</div>
      <div text-lg text-gray-300>移動、新增、刪除</div>
    </div>
  </div>
</div>

<div v-click="4" mt-12 text-center>
  <div class="px-12 py-6 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg inline-block">
    <div text-2xl text-yellow-300>
      🎯 以最小的性能開銷完成更新操作
    </div>
  </div>
</div>

<!--
具體來說，Diff 演算法有三大核心任務：

[點擊] 第一步：比較差異 - 對比新舊虛擬節點

[點擊] 第二步：找出復用 - 標記可復用的節點

[點擊] 第三步：計算操作 - 計算需要執行的移動、新增、刪除操作

[點擊] 最終目標就是以最小的性能開銷完成更新操作。
-->

---

# 本次分享的範圍

<div mt-12 text-2xl text-gray-300>
今天我們會介紹兩種<span text-yellow-300 font-bold>基礎但重要</span>的演算法
</div>

<div grid grid-cols-2 gap-8 mt-12>
  <div v-click="1" class="border-2 border-blue-500/30 rounded-lg p-8 bg-blue-900/20">
    <div text-2xl font-bold mb-6 text-blue-300>
      📖 第 9 章：簡單 Diff 演算法
    </div>
    <div text-lg space-y-3 text-gray-300>
      <div>• 核心概念：<code class="bg-blue-800/30 px-2 py-1 rounded">lastIndex</code> 與單向掃描</div>
      <div>• 理解如何判斷節點需要移動</div>
      <div>• 理解 <code class="bg-blue-800/30 px-2 py-1 rounded">key</code> 的作用</div>
    </div>
  </div>

  <div v-click="2" class="border-2 border-green-500/30 rounded-lg p-8 bg-green-900/20">
    <div text-2xl font-bold mb-6 text-green-300>
      📖 第 10 章：雙端 Diff 演算法
    </div>
    <div text-lg space-y-3 text-gray-300>
      <div>• 核心概念：從兩端向中間掃描</div>
      <div>• 理解如何減少移動次數</div>
      <div>• Vue 2 使用的演算法</div>
    </div>
  </div>
</div>

<!--
今天我們會介紹兩種基礎但重要的演算法：

[點擊] 第 9 章的簡單 Diff 演算法 - 核心概念是 lastIndex 與單向掃描，
我們會理解如何判斷節點需要移動，以及 key 的作用。

[點擊] 第 10 章的雙端 Diff 演算法 - 核心概念是從兩端向中間掃描，
我們會理解如何減少移動次數，這也是 Vue 2 使用的演算法。
-->

---
layout: intro
class: text-center
---

<div>
  <div text-6xl font-bold text-blue-400>準備好了嗎？</div>
  <div v-click mt-8 text-3xl text-gray-300>讓我們從最基礎的</div>
  <div v-click mt-4 text-5xl font-bold text-green-400>簡單 Diff 演算法</div>
  <div v-click mt-4 text-3xl text-gray-300>開始！🚀</div>
</div>

<!--
[點擊] 接下來，讓我們從最基礎的
[點擊] 簡單 Diff 演算法
[點擊] 開始！
-->
