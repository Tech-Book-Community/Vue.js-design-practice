---
layout: center
---

# 第 10 章：雙端 Diff 算法

<div class="mt-8 text-2xl text-gray-400">
從簡單 Diff 到更優的解決方案
</div>

<!--
上一章我們學習了簡單 Diff 算法，它利用 key 屬性來複用 DOM，透過 lastIndex 判斷是否需要移動節點。

但簡單 Diff 有個問題：移動次數不是最優的。這一章我們來看看雙端 Diff 算法如何解決這個問題。
-->

---
clicks: 15
---

# 簡單 Diff 的問題

<DiffAnimationMove :clicks="$clicks" />

<div v-click="15" class="mt-8 text-center">
  <span class="text-3xl text-red-400 font-bold">結果：2 次移動</span>
</div>

<!--
讓我們看一個例子。舊子節點是 p-1、p-2、p-3，新子節點是 p-3、p-1、p-2。

[點擊] 用簡單 Diff 算法來處理：

[點擊] 第一步，處理 p-3，它在舊節點中的索引是 2，大於等於 lastIndex 0，所以不需要移動，更新 lastIndex 為 2

[點擊] 第二步，處理 p-1，索引 0 小於 lastIndex 2，需要移動 p-1

[點擊] 第三步，處理 p-2，索引 1 小於 lastIndex 2，也需要移動 p-2

[點擊] 結果是 2 次移動
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 mb-8">但其實...</div>
  <div v-click class="text-3xl text-green-400 leading-relaxed">
    只要把 <span class="text-yellow-300 font-bold">p-3 移到最前面</span><br>
    <span class="text-5xl font-bold mt-4 inline-block">1 次移動就夠了！</span>
  </div>
</div>

<!--
但其實...

[點擊] 只要把 p-3 移到最前面，1 次移動就夠了！

這就是簡單 Diff 的問題：它沒辦法找到最優的移動方案。
-->

---

# 雙端 Diff 的核心思想

<div class="mt-8 text-2xl text-gray-300 mb-8">
同時從<span class="text-cyan-400 font-bold">兩端</span>進行比較，用四個索引：
</div>

<div class="grid grid-cols-2 gap-8">
  <div class="bg-green-900/20 border-2 border-green-500/40 rounded-lg p-6">
    <div class="text-xl font-bold mb-4 text-green-300">新子節點</div>
    <div class="flex justify-between items-center text-2xl font-mono">
      <span class="text-cyan-400">p-3</span>
      <span>p-1</span>
      <span class="text-orange-400">p-2</span>
    </div>
    <div class="flex justify-between mt-2 text-sm">
      <span class="text-cyan-400">↑ newStartIdx</span>
      <span class="text-orange-400">newEndIdx ↑</span>
    </div>
  </div>

  <div class="bg-blue-900/20 border-2 border-blue-500/40 rounded-lg p-6">
    <div class="text-xl font-bold mb-4 text-blue-300">舊子節點</div>
    <div class="flex justify-between items-center text-2xl font-mono">
      <span class="text-cyan-400">p-1</span>
      <span>p-2</span>
      <span class="text-orange-400">p-3</span>
    </div>
    <div class="flex justify-between mt-2 text-sm">
      <span class="text-cyan-400">↑ oldStartIdx</span>
      <span class="text-orange-400">oldEndIdx ↑</span>
    </div>
  </div>
</div>

<div v-click class="mt-8 text-center text-xl text-yellow-300">
四個索引指向新舊兩組子節點的<span class="font-bold">頭部</span>和<span class="font-bold">尾部</span>
</div>

<!--
雙端 Diff 的核心思想是：同時從兩端進行比較，用四個索引。

左邊是新子節點，右邊是舊子節點。
newStartIdx 和 oldStartIdx 指向頭部，用青色標示。
newEndIdx 和 oldEndIdx 指向尾部，用橙色標示。

[點擊] 這四個索引分別指向新舊兩組子節點的頭部和尾部。
-->

---

# 四步比較

<div class="mt-8 text-xl text-gray-300 mb-6">
每一輪比較分四步，命中任一步就處理，然後進入下一輪：
</div>

<div class="grid grid-cols-2 gap-6">
  <div v-click class="p-4 bg-cyan-900/20 border-2 border-cyan-500/40 rounded-lg">
    <div class="text-lg font-bold text-cyan-300 mb-2">① 頭頭比較</div>
    <div class="text-gray-300">newStart vs oldStart</div>
  </div>

  <div v-click class="p-4 bg-orange-900/20 border-2 border-orange-500/40 rounded-lg">
    <div class="text-lg font-bold text-orange-300 mb-2">② 尾尾比較</div>
    <div class="text-gray-300">newEnd vs oldEnd</div>
  </div>

  <div v-click class="p-4 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
    <div class="text-lg font-bold text-purple-300 mb-2">③ 交叉比較（新尾 vs 舊頭）</div>
    <div class="text-gray-300">newEnd vs oldStart</div>
  </div>

  <div v-click class="p-4 bg-pink-900/20 border-2 border-pink-500/40 rounded-lg">
    <div class="text-lg font-bold text-pink-300 mb-2">④ 交叉比較（新頭 vs 舊尾）</div>
    <div class="text-gray-300">newStart vs oldEnd</div>
  </div>
</div>

<div v-click class="mt-8 text-center text-xl text-green-400">
命中後執行對應操作，移動索引，進入下一輪
</div>

<!--
每一輪比較分四步：

[點擊] 第一步：頭頭比較，newStart 和 oldStart

[點擊] 第二步：尾尾比較，newEnd 和 oldEnd

[點擊] 第三步：交叉比較，newEnd 和 oldStart

[點擊] 第四步：交叉比較，newStart 和 oldEnd

[點擊] 命中任一步就執行對應操作，移動索引，然後進入下一輪。
-->

---

# 四種情況的移動邏輯

<div class="mt-6">
  <table class="w-full text-lg">
    <thead>
      <tr class="border-b border-gray-600">
        <th class="text-left py-3 text-gray-300">命中步驟</th>
        <th class="text-left py-3 text-gray-300">含義</th>
        <th class="text-left py-3 text-gray-300">操作</th>
      </tr>
    </thead>
    <tbody>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-cyan-400">步驟一</td>
        <td class="py-3">頭頭相同</td>
        <td class="py-3 text-green-400">不移動，只 patch</td>
      </tr>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-orange-400">步驟二</td>
        <td class="py-3">尾尾相同</td>
        <td class="py-3 text-green-400">不移動，只 patch</td>
      </tr>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-purple-400">步驟三</td>
        <td class="py-3">新尾 = 舊頭</td>
        <td class="py-3 text-yellow-400">舊頭移到舊尾後面</td>
      </tr>
      <tr v-click>
        <td class="py-3 text-pink-400">步驟四</td>
        <td class="py-3">新頭 = 舊尾</td>
        <td class="py-3 text-yellow-400">舊尾移到舊頭前面</td>
      </tr>
    </tbody>
  </table>
</div>

<!--
四種情況對應不同的移動邏輯：

[點擊] 步驟一，頭頭相同，不需要移動，只做 patch

[點擊] 步驟二，尾尾相同，同樣不需要移動，只做 patch

[點擊] 步驟三，新尾等於舊頭，需要把舊頭移到舊尾後面

[點擊] 步驟四，新頭等於舊尾，需要把舊尾移到舊頭前面
-->

---
clicks: 15
---

# 動畫演示

<DiffAnimationDoubleEnded :clicks="$clicks" />

<!--
讓我們通過動畫來演示雙端 Diff 的過程。

舊子節點是 p-1、p-2、p-3、p-4
新子節點是 p-4、p-2、p-1、p-3

動畫中的連線說明：
- 青色虛線：正在比較 Start 指標（頭部）
- 橙色虛線：正在比較 End 指標（尾部或交叉）
- 綠色實線：配對成功！

點擊或按空格鍵，跟著動畫一步步看雙端 Diff 是如何運作的。
-->

---

# 程式碼結構

<div class="overflow-y-auto max-h-100">

````md magic-move
```js
function patchChildren(n1, n2, container) {
  if (typeof n1.type === 'string') {
    // 省略部分
  } else if (Array.isArray(n2.children)) {
    // 封裝 patchKeyedChildren 函數處理兩組子節點
    patchKeyedChildren(n1, n2, container)
  } else {
    // 省略部分
  }
}

function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children
  const newChildren = n2.children

  // 四個索引
  let oldStartIdx = 0
  let oldEndIdx = oldChildren.length - 1
  let newStartIdx = 0
  let newEndIdx = newChildren.length - 1
}
```

```js {all|2-3|5-9|11-15|17-27}{lines:true}
function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children
  const newChildren = n2.children

  // 四個索引
  let oldStartIdx = 0
  let oldEndIdx = oldChildren.length - 1
  let newStartIdx = 0
  let newEndIdx = newChildren.length - 1

  // 四個節點
  let oldStartVNode = oldChildren[oldStartIdx]
  let oldEndVNode = oldChildren[oldEndIdx]
  let newStartVNode = newChildren[newStartIdx]
  let newEndVNode = newChildren[newEndIdx]

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVNode.key === newStartVNode.key) {
      // 步驟一：頭頭比較
    } else if (oldEndVNode.key === newEndVNode.key) {
      // 步驟二：尾尾比較
    } else if (oldStartVNode.key === newEndVNode.key) {
      // 步驟三：舊頭 vs 新尾
    } else if (oldEndVNode.key === newStartVNode.key) {
      // 步驟四：舊尾 vs 新頭
    }
  }
}
```
````

</div>

<!--
讓我們看看程式碼結構：

[點擊] 首先取得新舊兩組子節點

[點擊] 定義四個索引，分別指向新舊節點的頭部和尾部

[點擊] 定義四個節點變數，方便後續比較

[點擊] 在 while 循環中進行四步比較，命中任一步就執行對應操作
-->

---

# 步驟一、二：頭頭/尾尾相同

<div class="overflow-y-auto max-h-100">

```js {all|1-6|8-13}{lines:true}
// 步驟一：頭頭相同，不需要移動
if (oldStartVNode.key === newStartVNode.key) {
  patch(oldStartVNode, newStartVNode, container)
  oldStartVNode = oldChildren[++oldStartIdx]
  newStartVNode = newChildren[++newStartIdx]
}

// 步驟二：尾尾相同，不需要移動
else if (oldEndVNode.key === newEndVNode.key) {
  patch(oldEndVNode, newEndVNode, container)
  oldEndVNode = oldChildren[--oldEndIdx]
  newEndVNode = newChildren[--newEndIdx]
}
```

</div>

<div v-click class="mt-8 p-4 bg-green-900/20 border-2 border-green-500/40 rounded-lg">
  <div class="text-xl text-green-300">
    <span class="font-bold">關鍵點：</span>頭頭或尾尾相同時，節點位置不變，只需要 patch 更新內容
  </div>
</div>

<!--
步驟一和步驟二的邏輯很簡單：

[點擊] 步驟一：頭頭相同，調用 patch 更新節點，然後兩個 start 索引都往後移動

[點擊] 步驟二：尾尾相同，調用 patch 更新節點，然後兩個 end 索引都往前移動

[點擊] 關鍵點是：頭頭或尾尾相同時，節點位置不需要改變，只需要 patch 更新內容就好。
-->

---

# 步驟三、四：交叉比較

<div class="overflow-y-auto max-h-100">

```js {all|1-7|9-15}{lines:true}
// 步驟三：舊頭 = 新尾，移動到尾部
else if (oldStartVNode.key === newEndVNode.key) {
  patch(oldStartVNode, newEndVNode, container)
  insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)
  oldStartVNode = oldChildren[++oldStartIdx]
  newEndVNode = newChildren[--newEndIdx]
}

// 步驟四：舊尾 = 新頭，移動到頭部
else if (oldEndVNode.key === newStartVNode.key) {
  patch(oldEndVNode, newStartVNode, container)
  insert(oldEndVNode.el, container, oldStartVNode.el)
  oldEndVNode = oldChildren[--oldEndIdx]
  newStartVNode = newChildren[++newStartIdx]
}
```

</div>

<div v-click class="mt-8 p-4 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg">
  <div class="text-xl text-yellow-300">
    <span class="font-bold">關鍵點：</span>交叉比較命中時，需要移動 DOM 節點到對應位置
  </div>
</div>

<!--
步驟三和步驟四是交叉比較：

[點擊] 步驟三：舊頭等於新尾，說明這個節點要移到尾部。先 patch，然後用 insert 把它移到 oldEnd 的後面。

[點擊] 步驟四：舊尾等於新頭，說明這個節點要移到頭部。先 patch，然後用 insert 把它移到 oldStart 的前面。

[點擊] 關鍵點是：交叉比較命中時，需要移動 DOM 節點到對應位置。
-->

---

# 雙端 Diff 的優勢

<div class="mt-8">
  <div class="text-2xl text-gray-300 mb-6">用之前的例子對比：</div>

  <div class="grid grid-cols-2 gap-8 mb-8">
    <div class="bg-gray-800/50 rounded-lg p-4">
      <div class="text-lg text-gray-400 mb-2">舊：</div>
      <div class="text-xl font-mono">[p-1, p-2, p-3]</div>
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
      <div class="text-lg text-gray-400 mb-2">新：</div>
      <div class="text-xl font-mono">[p-3, p-1, p-2]</div>
    </div>
  </div>

  <table class="w-full text-xl">
    <thead>
      <tr class="border-b border-gray-600">
        <th class="text-left py-3 text-gray-300">算法</th>
        <th class="text-left py-3 text-gray-300">移動次數</th>
        <th class="text-left py-3 text-gray-300">移動的節點</th>
      </tr>
    </thead>
    <tbody>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-blue-400">簡單 Diff</td>
        <td class="py-3 text-red-400 font-bold">2 次</td>
        <td class="py-3">移動 p-1, p-2</td>
      </tr>
      <tr v-click>
        <td class="py-3 text-green-400">雙端 Diff</td>
        <td class="py-3 text-green-400 font-bold">1 次</td>
        <td class="py-3">移動 p-3</td>
      </tr>
    </tbody>
  </table>
</div>

<div v-click class="mt-8 text-center text-xl text-yellow-300">
雙端 Diff 能發現「舊尾 = 新頭」的情況，直接把 p-3 移到最前面
</div>

<!--
讓我們用之前的例子來對比兩種算法的效果。

舊子節點是 p-1、p-2、p-3，新子節點是 p-3、p-1、p-2。

[點擊] 簡單 Diff 需要 2 次移動，移動 p-1 和 p-2

[點擊] 雙端 Diff 只需要 1 次移動，移動 p-3

[點擊] 原因是雙端 Diff 能發現「舊尾等於新頭」的情況，直接把 p-3 移到最前面就搞定了。
-->

---
layout: center
---

# 小結

<div class="grid grid-cols-2 gap-8 mt-12">
  <div class="p-6 bg-blue-900/20 border-2 border-blue-500/40 rounded-lg">
    <div class="text-2xl font-bold text-blue-300 mb-4">簡單 Diff</div>
    <ul class="space-y-2 text-gray-300">
      <li>單向遍歷</li>
      <li>用 lastIndex 判斷移動</li>
      <li>移動次數較多</li>
    </ul>
  </div>

  <div class="p-6 bg-green-900/20 border-2 border-green-500/40 rounded-lg">
    <div class="text-2xl font-bold text-green-300 mb-4">雙端 Diff</div>
    <ul class="space-y-2 text-gray-300">
      <li>雙端四步比較</li>
      <li>四種情況對應移動</li>
      <li>移動次數較少</li>
    </ul>
  </div>
</div>

<div v-click class="mt-12 text-center text-2xl text-yellow-300">
下一節：非理想狀況的處理
</div>

<!--
讓我們總結一下這一節的內容：

簡單 Diff 採用單向遍歷，用 lastIndex 判斷是否需要移動，但移動次數可能較多。

雙端 Diff 採用雙端四步比較，四種情況對應不同的移動策略，移動次數更少。

[點擊] 下一節我們會學習：如果四步比較都沒有命中怎麼辦？也就是非理想狀況的處理。
-->
