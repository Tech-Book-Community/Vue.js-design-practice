---
layout: center
---

# 添加新元素

<div class="mt-8 text-2xl text-gray-400">
當新子節點中出現舊子節點沒有的元素時
</div>

<!--
這一節我們來看添加新元素的情況。

上一節學了非理想狀況的處理：在舊節點中查找 newStartVNode。但如果找不到呢？這就代表它是一個新的節點，需要掛載。
-->

---
clicks: 6
---

# 情況一：四步沒命中且找不到

<DiffAnimationAddImmediate :clicks="$clicks" />

<!--
先看第一種情況：四步比較都沒命中，在舊節點中也找不到。

舊子節點是 p-1、p-2、p-3，新子節點是 p-4、p-1、p-3、p-2。

點擊或按空格鍵查看動畫。你會看到第一輪四步比較都沒命中，然後去舊節點中查找 p-4，但找不到。這代表 p-4 是新增節點，要立即掛載。
-->

---

# 立即掛載新節點

<div class="mt-8 text-xl text-gray-300 mb-6">
修改非理想狀況的 else 分支：
</div>

<div class="bg-gray-800/50 rounded-lg p-6">

```js {all|1-2|3-6|7-10}{lines:true}
else {
  const idxInOld = oldChildren.findIndex(node => node.key === newStartVNode.key)

  if (idxInOld > 0) {
    // 找到了，移動到頭部
    // ...
  } else {
    // 找不到，說明是新節點，直接掛載
    patch(null, newStartVNode, container, oldStartVNode.el)
  }

  newStartVNode = newChildren[++newStartIdx]
}
```

</div>

<!--
程式碼要怎麼修改？我們在非理想狀況的 else 分支加上處理。

[點擊] 首先用 findIndex 在舊節點中查找。

[點擊] 如果 idxInOld 大於 0，說明找到了，這是上一節講的移動到頭部的情況。

[點擊] 但如果找不到，idxInOld 會是 -1，這時候就直接掛載新節點。patch 函數第一個參數傳 null，代表這是掛載操作，不是更新。
-->

---
clicks: 16
---

# 完整流程演示

<DiffAnimationAddImmediate :clicks="$clicks" />

<!--
現在讓我們看完整的流程。

p-4 掛載完成後，會繼續進行後續的雙端比較，直到所有節點都處理完畢。

點擊或按空格鍵查看完整動畫。
-->

---
layout: center
---

# 這樣就完美了嗎？

<div v-click class="mt-12 text-3xl text-gray-300">
答案是<span class="text-red-400 font-bold">否定的</span>
</div>

<div v-click class="mt-8 text-xl text-gray-400">
讓我們再來看另一個例子...
</div>

<!--
p-4 掛載完成後，會繼續進行後續的更新，直到全部完成。

[點擊] 但這樣就完美了嗎？答案是否定的。

[點擊] 讓我們再來看另一個例子，看看還有什麼情況需要處理。
-->

---
clicks: 10
---

# 情況二：循環結束後還有遺漏

<div class="mt--2">
  <DiffAnimationAdd :clicks="$clicks" />
</div>

<div v-click="10" class="mt-2 p-1 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg text-center">
  <div class="text-lg text-yellow-300">
    循環結束！但 p-4 被遺漏了！
  </div>
</div>

<!--
第二種情況更隱蔽：有些新節點可能在迴圈中被「跳過」。

舊子節點是 p-1、p-2、p-3，新子節點是 p-4、p-1、p-2、p-3。

點擊看動畫。你會發現每一輪都是尾尾比較命中：p-3 配 p-3、p-2 配 p-2、p-1 配 p-1。

三輪之後迴圈就結束了！但 p-4 完全沒有被處理到！
-->

---

# 為什麼會遺漏？

<div class="mt-6">
  <div class="text-xl text-gray-300 mb-6">
    讓我們看看循環結束時的索引狀態：
  </div>

  <div class="grid grid-cols-2 gap-8">
    <div class="p-4 bg-gray-800/50 rounded-lg">
      <div class="text-lg font-bold text-gray-400 mb-3">舊子節點索引</div>
      <div class="font-mono text-lg">
        <div class="flex gap-4 mb-2">
          <span class="text-cyan-400">oldStartIdx = 1</span>
        </div>
        <div class="flex gap-4">
          <span class="text-orange-400">oldEndIdx = 0</span>
        </div>
      </div>
      <div v-click class="mt-3 text-red-400 font-bold">
        oldEndIdx < oldStartIdx → 舊節點處理完了！
      </div>
    </div>
    <div class="p-4 bg-gray-800/50 rounded-lg">
      <div class="text-lg font-bold text-gray-400 mb-3">新子節點索引</div>
      <div class="font-mono text-lg">
        <div class="flex gap-4 mb-2">
          <span class="text-cyan-400">newStartIdx = 0</span>
        </div>
        <div class="flex gap-4">
          <span class="text-orange-400">newEndIdx = 0</span>
        </div>
      </div>
      <div v-click class="mt-3 text-yellow-400 font-bold">
        newStartIdx <= newEndIdx → 還有新節點沒處理！
      </div>
    </div>
  </div>

  <div v-click class="mt-6 text-center text-2xl text-emerald-400 font-bold">
    索引 0 的 p-4 還沒處理，需要在循環結束後補掛載
  </div>
</div>

<!--
為什麼會遺漏？讓我們看看迴圈結束時的索引狀態。

[點擊] 舊子節點這邊：oldEndIdx 變成 0，小於 oldStartIdx 的 1。這代表舊節點都處理完了，迴圈會結束。

[點擊] 但看新子節點：newStartIdx 還是 0，newEndIdx 也是 0。這代表索引 0 的位置還有節點沒處理！

[點擊] 沒錯，p-4 完全被跳過了！我們需要在迴圈結束後補掛載這些遺漏的節點。
-->

---

# 循環結束後的檢查

<div class="mt-6 text-xl text-gray-300 mb-4">
在 while 循環結束後添加檢查：
</div>

<div class="bg-gray-800/50 rounded-lg p-5">

````md magic-move
```js {all}{lines:true}
while (oldStartIdx < oldEndIdx && newStartIdx <= newEndIdx) {
  // 省略
}

// 循環結束後
if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
  //
}
```

```js {all|2|3-4|5-8}{lines:true}
// 循環結束後
if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
  // 舊節點處理完了，但還有新節點沒處理
  // 需要掛載這些新節點
  for (let i = newStartIdx; i <= newEndIdx; i++) {
    // 掛載到 oldStartVNode.el 之前
    patch(null, newChildren[i], container, oldStartVNode.el)
  }
}
```
````

</div>

<div v-click class="mt-6 grid grid-cols-2 gap-4">
  <div class="p-4 bg-cyan-900/20 border border-cyan-500/40 rounded-lg">
    <div class="text-cyan-300 font-bold mb-2">條件判斷</div>
    <div class="text-sm text-gray-300">
      <code>oldEndIdx < oldStartIdx</code>：舊節點處理完<br>
      <code>newStartIdx <= newEndIdx</code>：新節點還有剩
    </div>
  </div>
  <div class="p-4 bg-purple-900/20 border border-purple-500/40 rounded-lg">
    <div class="text-purple-300 font-bold mb-2">插入位置</div>
    <div class="text-sm text-gray-300">
      <code>oldStartVNode.el</code>：作為錨點<br>
      新節點會插入到這個位置之前
    </div>
  </div>
</div>

<!--
那怎麼處理？在 while 迴圈結束後加一個檢查。

[點擊] 條件是：oldEndIdx 小於 oldStartIdx，代表舊節點都處理完了。

[點擊] 同時 newStartIdx 小於等於 newEndIdx，代表還有新節點沒處理。

[點擊] 符合條件的話，就用 for 迴圈把剩餘的新節點逐一掛載，錨點是 oldStartVNode.el。

這邊注意 for 迴圈用的是 `i <= newEndIdx`，因為 newStartIdx 到 newEndIdx 是閉區間，兩端都要包含。
-->

---
clicks: 13
---

# 動畫演示

<DiffAnimationAdd :clicks="$clicks" />

<!--
讓我們用動畫來完整演示這個情況。

舊子節點是 p-1、p-2、p-3，新子節點是 p-4、p-1、p-2、p-3。

你會看到每一輪都是尾尾比較命中，p-4 被跳過。迴圈結束後，檢測到還有新節點沒處理，於是補掛載 p-4。

點擊或按空格鍵查看動畫。
-->

---

# 兩種添加情況對比

<div class="mt-8">
  <div class="grid grid-cols-2 gap-8">
    <div v-click class="p-6 bg-cyan-900/20 border-2 border-cyan-500/40 rounded-lg">
      <div class="text-xl text-cyan-300 font-bold mb-4">情況一：循環中添加</div>
      <div class="space-y-3 text-gray-300">
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span>四步比較都沒命中</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span>在舊節點中找不到</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span><strong>立即掛載</strong>到 oldStartVNode.el 之前</span>
        </div>
      </div>
    </div>
    <div v-click class="p-6 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
      <div class="text-xl text-purple-300 font-bold mb-4">情況二：循環後添加</div>
      <div class="space-y-3 text-gray-300">
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span>舊節點先處理完畢</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span>新節點還有剩餘</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span><strong>循環後補掛載</strong>剩餘的新節點</span>
        </div>
      </div>
    </div>
  </div>
</div>

<div v-click class="mt-8 p-4 bg-emerald-900/20 border-2 border-emerald-500/40 rounded-lg text-center">
  <div class="text-xl text-emerald-300">
    兩種情況都使用 <code class="font-mono">patch(null, newVNode, ...)</code> 進行掛載
  </div>
</div>

<!--
好，讓我們對比一下這兩種添加新元素的情況。

[點擊] 情況一是在迴圈中添加：四步都沒命中，在舊節點中也找不到，這時候立即掛載。

[點擊] 情況二是在迴圈後添加：舊節點先處理完了，但新節點還有剩餘，迴圈結束後再補掛載。

[點擊] 兩種情況的核心操作是一樣的，都是用 patch(null, newVNode, ...) 來掛載，第一個參數傳 null 代表這是掛載操作。
-->

---
layout: center
---

# 小結

<div class="mt-12 space-y-6 text-xl">
  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-cyan-400 font-bold">情況一：</span>
    <span class="text-gray-300">四步沒命中且找不到 → 立即掛載</span>
  </div>

  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-purple-400 font-bold">情況二：</span>
    <span class="text-gray-300">循環結束後還有剩餘 → 補掛載</span>
  </div>

  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-emerald-400 font-bold">核心操作：</span>
    <span class="text-gray-300"><code>patch(null, newVNode, container, anchor)</code></span>
  </div>
</div>

<div v-click class="mt-12 text-center text-2xl text-yellow-300">
下一節：移除不存在的元素
</div>

<!--
來做個小結。

[點擊] 情況一：四步沒命中而且在舊節點找不到，就立即掛載。

[點擊] 情況二：迴圈結束後還有剩餘的新節點，要補掛載。

[點擊] 核心操作都是 patch(null, newVNode, container, anchor)，第一個參數是 null。

[點擊] 下一節我們來看相反的情況：移除不存在的元素。
-->
