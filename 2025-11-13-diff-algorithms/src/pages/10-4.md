---
layout: center
---

# 添加新元素

<div class="mt-8 text-2xl text-gray-400">
當新子節點中出現舊子節點沒有的元素時
</div>

<!--
上一節我們學習了非理想狀況的處理：在舊節點中查找 newStartVNode。

但如果找不到呢？這就是「添加新元素」的情況。
-->

---
clicks: 6
---

# 情況一：四步沒命中且找不到

<DiffAnimationAddImmediate :clicks="$clicks" />

<!--
第一種情況是：四步比較都沒命中，在舊節點中也找不到。

舊子節點是 p-1、p-2、p-3，新子節點是 p-4、p-1、p-3、p-2。

讓我們通過動畫來看這個過程：
- 第一輪四步比較都沒命中
- 去舊節點中查找 p-4，但找不到！
- 說明 p-4 是新增節點，立即掛載

點擊或按空格鍵查看動畫。
-->

---

# 立即掛載新節點

<div class="mt-8 text-xl text-gray-300 mb-6">
修改非理想狀況的 else 分支：
</div>

<div class="bg-gray-800/50 rounded-lg p-6">

```js {all|1-2|3-6|7-10}{lines:true}
else {
  const idxInOld = oldChildren.findIndex(node => node.key === newStartVNode.key)

  if (idxInOld > 0) {
    // 找到了，移動到頭部
    // ...
  } else {
    // 找不到，說明是新節點，直接掛載
    patch(null, newStartVNode, container, oldStartVNode.el)
  }

  newStartVNode = newChildren[++newStartIdx]
}
```

</div>

<!--
我們需要修改非理想狀況的 else 分支。

[點擊] 首先在舊節點中查找

[點擊] 如果 idxInOld 大於 0，說明找到了，移動到頭部

[點擊] 如果找不到（idxInOld 為 -1 或 0），就直接掛載新節點

[點擊] patch 函數第一個參數為 null 表示這是掛載操作，而非更新。
-->

---
clicks: 16
---

# 完整流程演示

<DiffAnimationAddImmediate :clicks="$clicks" />

<!--
現在讓我們看完整的流程：
- p-4 掛載完成後，繼續進行後續的雙端比較
- 直到所有節點都處理完畢

點擊或按空格鍵查看完整動畫。
-->

---
layout: center
---

# 這樣就完美了嗎？

<div v-click class="mt-12 text-3xl text-gray-300">
答案是<span class="text-red-400 font-bold">否定的</span>
</div>

<div v-click class="mt-8 text-xl text-gray-400">
讓我們再來看另一個例子...
</div>

<!--
當新節點 p-4 掛載完成後，會進行後續的更新，直到全部更新完成為止。

[點擊] 但這樣就完美了嗎？答案是否定的。

[點擊] 讓我們再來看另一個例子，看看還有什麼情況需要處理。
-->

---
clicks: 10
---

# 情況二：循環結束後還有遺漏

<div class="mt--2">
  <DiffAnimationAdd :clicks="$clicks" />
</div>

<div v-click="10" class="mt-2 p-1 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg text-center">
  <div class="text-lg text-yellow-300">
    循環結束！但 p-4 被遺漏了！
  </div>
</div>

<!--
第二種情況更隱蔽：有些新節點可能在循環中被「跳過」。

舊子節點是 p-1、p-2、p-3，新子節點是 p-4、p-1、p-2、p-3。

[點擊] 第一輪：尾尾比較 p-3 vs p-3 命中
第二輪：尾尾比較 p-2 vs p-2 命中
第三輪：尾尾比較 p-1 vs p-1 命中

[點擊] 循環結束了！但 p-4 完全沒有被處理到！
-->

---

# 為什麼會遺漏？

<div class="mt-6">
  <div class="text-xl text-gray-300 mb-6">
    讓我們看看循環結束時的索引狀態：
  </div>

  <div class="grid grid-cols-2 gap-8">
    <div class="p-4 bg-gray-800/50 rounded-lg">
      <div class="text-lg font-bold text-gray-400 mb-3">舊子節點索引</div>
      <div class="font-mono text-lg">
        <div class="flex gap-4 mb-2">
          <span class="text-cyan-400">oldStartIdx = 1</span>
        </div>
        <div class="flex gap-4">
          <span class="text-orange-400">oldEndIdx = 0</span>
        </div>
      </div>
      <div v-click class="mt-3 text-red-400 font-bold">
        oldEndIdx < oldStartIdx → 舊節點處理完了！
      </div>
    </div>
    <div class="p-4 bg-gray-800/50 rounded-lg">
      <div class="text-lg font-bold text-gray-400 mb-3">新子節點索引</div>
      <div class="font-mono text-lg">
        <div class="flex gap-4 mb-2">
          <span class="text-cyan-400">newStartIdx = 0</span>
        </div>
        <div class="flex gap-4">
          <span class="text-orange-400">newEndIdx = 0</span>
        </div>
      </div>
      <div v-click class="mt-3 text-yellow-400 font-bold">
        newStartIdx <= newEndIdx → 還有新節點沒處理！
      </div>
    </div>
  </div>

  <div v-click class="mt-6 text-center text-2xl text-emerald-400 font-bold">
    索引 0 的 p-4 還沒處理，需要在循環結束後補掛載
  </div>
</div>

<!--
讓我們看看循環結束時的索引狀態：

[點擊] 舊子節點：oldEndIdx 小於 oldStartIdx，表示舊節點都處理完了

[點擊] 新子節點：newStartIdx 等於 newEndIdx，等於 0，表示還有新節點沒處理

[點擊] 沒錯，索引 0 的 p-4 完全被跳過了！我們需要在循環結束後補掛載。
-->

---

# 循環結束後的檢查

<div class="mt-6 text-xl text-gray-300 mb-4">
在 while 循環結束後添加檢查：
</div>

<div class="bg-gray-800/50 rounded-lg p-5">

````md magic-move
```js {all}{lines:true}
while (oldStartIdx < oldEndIdx && newStartIdx <= newEndIdx) {
  // 省略
}

// 循環結束後
if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
  //
}
```

```js {all|2|3-4|5-8}{lines:true}
// 循環結束後
if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
  // 舊節點處理完了，但還有新節點沒處理
  // 需要掛載這些新節點
  for (let i = newStartIdx; i <= newEndIdx; i++) {
    // 掛載到 oldStartVNode.el 之前
    patch(null, newChildren[i], container, oldStartVNode.el)
  }
}
```
````

</div>

<div v-click class="mt-6 grid grid-cols-2 gap-4">
  <div class="p-4 bg-cyan-900/20 border border-cyan-500/40 rounded-lg">
    <div class="text-cyan-300 font-bold mb-2">條件判斷</div>
    <div class="text-sm text-gray-300">
      <code>oldEndIdx < oldStartIdx</code>：舊節點處理完<br>
      <code>newStartIdx <= newEndIdx</code>：新節點還有剩
    </div>
  </div>
  <div class="p-4 bg-purple-900/20 border border-purple-500/40 rounded-lg">
    <div class="text-purple-300 font-bold mb-2">插入位置</div>
    <div class="text-sm text-gray-300">
      <code>oldStartVNode.el</code>：作為錨點<br>
      新節點會插入到這個位置之前
    </div>
  </div>
</div>

<!--
在 while 循環結束後添加檢查：

[點擊] 條件是：oldEndIdx 小於 oldStartIdx，表示舊節點都處理完了

[點擊] 同時 newStartIdx 小於等於 newEndIdx，表示還有新節點沒處理

[點擊] 遍歷剩餘的新節點，逐一掛載到 oldStartVNode.el 之前

[點擊] 左邊是條件判斷的含義，右邊是插入位置的說明。

補充說明 for 迴圈的條件 `i <= newEndIdx`：

newStartIdx 到 newEndIdx 是「還沒處理的新節點範圍」（閉區間）

例如：舊 [p-1, p-2, p-3] → 新 [p-4, p-1, p-2, p-3]
三輪尾尾比較後：newStartIdx=0, newEndIdx=0，都指向 p-4
迴圈 i=0：掛載 p-4

如果有多個遺漏：舊 [p-1] → 新 [p-2, p-3, p-4, p-1]
尾尾比較 p-1 後：newStartIdx=0, newEndIdx=2
迴圈 i=0,1,2：依序掛載 p-2, p-3, p-4

用 <= 是因為兩端索引都要包含。
-->

---
clicks: 13
---

# 動畫演示

<DiffAnimationAdd :clicks="$clicks" />

<!--
讓我們通過動畫來演示添加新元素的過程。

舊子節點是 p-1、p-2、p-3
新子節點是 p-4、p-1、p-2、p-3

每一輪都是尾尾比較命中，p-4 被跳過。
循環結束後，檢測到還有新節點沒處理，於是掛載 p-4。

點擊或按空格鍵查看動畫。
-->

---

# 兩種添加情況對比

<div class="mt-8">
  <div class="grid grid-cols-2 gap-8">
    <div v-click class="p-6 bg-cyan-900/20 border-2 border-cyan-500/40 rounded-lg">
      <div class="text-xl text-cyan-300 font-bold mb-4">情況一：循環中添加</div>
      <div class="space-y-3 text-gray-300">
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span>四步比較都沒命中</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span>在舊節點中找不到</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-cyan-400">•</span>
          <span><strong>立即掛載</strong>到 oldStartVNode.el 之前</span>
        </div>
      </div>
    </div>
    <div v-click class="p-6 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
      <div class="text-xl text-purple-300 font-bold mb-4">情況二：循環後添加</div>
      <div class="space-y-3 text-gray-300">
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span>舊節點先處理完畢</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span>新節點還有剩餘</span>
        </div>
        <div class="flex items-start gap-2">
          <span class="text-purple-400">•</span>
          <span><strong>循環後補掛載</strong>剩餘的新節點</span>
        </div>
      </div>
    </div>
  </div>
</div>

<div v-click class="mt-8 p-4 bg-emerald-900/20 border-2 border-emerald-500/40 rounded-lg text-center">
  <div class="text-xl text-emerald-300">
    兩種情況都使用 <code class="font-mono">patch(null, newVNode, ...)</code> 進行掛載
  </div>
</div>

<!--
讓我們對比兩種添加新元素的情況：

[點擊] 情況一是在循環中添加：四步都沒命中，在舊節點中也找不到，立即掛載。

[點擊] 情況二是在循環後添加：舊節點先處理完，但新節點還有剩餘，循環結束後補掛載。

[點擊] 兩種情況都使用 patch(null, newVNode, ...) 進行掛載，第一個參數為 null 表示掛載操作。
-->

---
layout: center
---

# 小結

<div class="mt-12 space-y-6 text-xl">
  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-cyan-400 font-bold">情況一：</span>
    <span class="text-gray-300">四步沒命中且找不到 → 立即掛載</span>
  </div>

  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-purple-400 font-bold">情況二：</span>
    <span class="text-gray-300">循環結束後還有剩餘 → 補掛載</span>
  </div>

  <div v-click class="p-4 bg-gray-800/50 rounded-lg">
    <span class="text-emerald-400 font-bold">核心操作：</span>
    <span class="text-gray-300"><code>patch(null, newVNode, container, anchor)</code></span>
  </div>
</div>

<div v-click class="mt-12 text-center text-2xl text-yellow-300">
下一節：移除不存在的元素
</div>

<!--
讓我們總結這一節的內容：

[點擊] 情況一：四步沒命中且找不到，立即掛載

[點擊] 情況二：循環結束後還有剩餘的新節點，補掛載

[點擊] 核心操作都是 patch(null, newVNode, container, anchor)

[點擊] 下一節我們會學習相反的情況：移除不存在的元素。
-->
