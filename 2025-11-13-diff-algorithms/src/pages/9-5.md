---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-green-400 mb-12">
    添加新元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    掛載在舊子節點中<br>
    <span class="text-yellow-300 font-bold">不存在</span>的新節點
  </div>
</div>

<!--
9.5 添加新元素

[點擊] 掛載在舊子節點中不存在的新節點
-->

---

# 問題：新節點不存在於舊 children

<div class="mt--4 scale-75">
  <NodesMapping
    :rows="[
      { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
      { newNode: 'p-2', index: 1 },
      { newNode: 'p-1', oldNode: 'p-3', index: 2, targetIndex: 0 },
      { newNode: 'p-4', index: 3 },
    ]"
  />
</div>

<div v-click class="mt--8 bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-yellow-300">
    <span class="text-green-400 font-bold">p-2</span> 和 <span class="text-green-400 font-bold">p-4</span> 在舊子節點中<span class="font-bold">不存在</span>，需要掛載（mount）
  </div>
</div>

<!--
問題：新節點不存在於舊 children

舊子節點只有 p-1 和 p-3

新子節點有 p-3, p-2, p-1, p-4

[點擊] p-2 和 p-4 在舊子節點中不存在，這時候不是移動，而是要掛載新節點
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    如何識別新增節點？
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed mb-8">
    使用標誌變量<br>
    <span class="text-yellow-300 font-bold font-mono text-5xl">find</span>
  </div>

  <div v-click class="text-2xl text-gray-400">
    遍歷完舊節點後<br>
    <code class="text-green-300">find === false</code> → 新增節點
  </div>
</div>

<!--
如何識別新增節點？

[點擊] 使用標誌變量 find

[點擊] 遍歷完舊節點後，如果 find 還是 false，說明是新增節點
-->

---

# find 標誌變量

<div class="overflow-y-auto max-h-100 mt-4">

```js {all|3|7|13-14|all}{lines:true}
for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  let find = false  // 初始化為 false

  for (let j = 0; j < oldChildren.length; j++) {
    if (newVNode.key === oldVNode.key) {
      find = true  // 找到了！
      // ... patch 和移動邏輯
      break
    }
  }

  if (!find) {
    // 沒找到 → 新增節點，需要掛載
  }
}
```

</div>

<!--
find 標誌變量的使用：

[點擊] 初始化 find 為 false，假設找不到

[點擊] 如果找到相同 key 的節點，設置 find 為 true

[點擊] 內層循環結束後，如果 find 仍為 false，說明是新增節點，需要掛載
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-purple-300 mb-12">
    新節點要掛載到哪裡？
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    前一個節點的後面
  </div>

  <div v-click class="text-2xl text-gray-300 font-mono">
    anchor = prevVNode.el.nextSibling
  </div>
</div>

<!--
新節點要掛載到哪裡？

[點擊] 答案：前一個節點的後面

[點擊] 取 prevVNode.el.nextSibling 作為錨點
-->

---

# 確定掛載位置

<div class="mt-6">
  <div class="text-center text-sm text-gray-400 mb-4">新子節點：找到前一個節點作為參考</div>
  
  <div class="flex justify-center items-center gap-3">
    <!-- p-3 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div class="text-xs text-gray-500 mt-1">索引 0</div>
    </div>
    <!-- 箭頭指向 p-2 -->
    <div v-click="1" class="flex flex-col items-center">
      <div class="text-yellow-400 text-xs mb-1">prevVNode</div>
      <div class="text-2xl text-yellow-400">→</div>
    </div>
    <!-- p-2 (新增) -->
    <div v-click="2" class="text-center">
      <div class="w-14 h-10 bg-green-600 border-2 border-green-400 rounded flex items-center justify-center text-white text-sm font-bold">p-2</div>
      <div class="text-xs text-green-400 mt-1">新增!</div>
    </div>
    <!-- p-1 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div class="text-xs text-gray-500 mt-1">索引 2</div>
    </div>
    <!-- p-4 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-4</div>
      <div class="text-xs text-gray-500 mt-1">索引 3</div>
    </div>
  </div>

  <div v-click="1" class="mt-6 flex justify-center">
    <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4 text-center">
      <div class="text-blue-300 text-sm">
        p-2 的前一個節點是 <span class="text-yellow-300 font-bold">p-3</span><br>
        → 掛載到 <span class="text-yellow-300 font-mono">p-3.el.nextSibling</span> 前面
      </div>
    </div>
  </div>
</div>

<div v-click="3" class="mt-4 bg-green-900/20 border border-green-500/30 rounded-lg p-3">

```js
const prevVNode = newChildren[i - 1]  // p-3
const anchor = prevVNode.el.nextSibling
patch(null, newVNode, container, anchor)  // 掛載新節點
```
</div>

<!--
確定掛載位置：

p-2 在新子節點中排在 p-3 後面

[點擊] 所以 p-2 應該掛載到 p-3 對應的真實 DOM 後面

取 prevVNode.el.nextSibling 作為錨點，然後調用 patch

注意 patch 的第一個參數是 null，表示這是新建而非更新
-->

---

# 特殊情況：第一個節點是新增的

<div class="mt-6">
  <div class="text-center text-sm text-red-300 mb-4">問題：prevVNode 不存在怎麼辦？</div>
  
  <div class="flex justify-center items-center gap-3">
    <!-- p-4 (新增) - 第一個 -->
    <div v-click="2" class="text-center">
      <div class="w-14 h-10 bg-green-600 border-2 border-green-400 rounded flex items-center justify-center text-white text-sm font-bold">p-4</div>
      <div class="text-xs text-green-400 mt-1">新增!</div>
    </div>
    <!-- p-1 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div class="text-xs text-gray-500 mt-1">索引 1</div>
    </div>
    <!-- p-2 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-2</div>
      <div class="text-xs text-gray-500 mt-1">索引 2</div>
    </div>
    <!-- p-3 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div class="text-xs text-gray-500 mt-1">索引 3</div>
    </div>
  </div>

  <div class="mt-4 flex justify-center">
    <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
      <div class="text-red-300 text-sm">
        p-4 是第一個節點，<span class="text-red-400 font-bold">沒有前一個節點</span><br>
        prevVNode = <span class="text-red-400 font-mono">undefined</span> ❌
      </div>
    </div>
  </div>
</div>

<div v-click class="mt-4 grid grid-cols-2 gap-4">
  <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-3 text-center">
    <div class="text-green-300 text-sm mb-2">解決方案</div>
    <div class="text-yellow-300 font-mono text-sm">anchor = container.firstChild</div>
    <div class="text-gray-400 text-xs mt-1">插到容器最前面</div>
  </div>
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3">

```js
if (prevVNode) {
  anchor = prevVNode.el.nextSibling
} else {
  anchor = container.firstChild
}
```
  </div>
</div>

<!--
特殊情況：第一個節點是新增的

如果第一個節點就是新增的，prevVNode 不存在怎麼辦？

[點擊] 解決方案：用 container.firstChild 作為錨點，把新節點插到容器的最前面
-->

---
clicks: 18
---

# 完整案例演示

<div class="mt-8"></div>

<DiffAnimationMount :clicks="$clicks" />

<!--
完整案例演示

案例：[p-1, p-3] → [p-3, p-2, p-1, p-4]

請點擊或按空格鍵逐步查看動畫演示

（動畫共 18 步，展示新增節點的掛載過程）
-->

---

# 完整實現代碼

<div class="overflow-y-auto max-h-100 mt-2">

```js {all|3|16-26|all}{lines:true}
for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  let find = false

  for (let j = 0; j < oldChildren.length; j++) {
    if (newVNode.key === oldVNode.key) {
      find = true
      patch(oldVNode, newVNode, container)
      // ... 移動邏輯
      break
    }
  }

  // 如果 find 為 false，說明是新增節點
  if (!find) {
    const prevVNode = newChildren[i - 1]
    let anchor = null

    if (prevVNode) {
      anchor = prevVNode.el.nextSibling
    } else {
      anchor = container.firstChild
    }

    // 掛載新節點
    patch(null, newVNode, container, anchor)
  }
}
```

</div>

<!--
完整實現代碼：

[點擊] find 標誌變量，初始為 false

[點擊] 如果 find 為 false，計算錨點位置：
- 有 prevVNode → 用它的 nextSibling
- 沒有 → 用 container.firstChild

然後調用 patch(null, newVNode, container, anchor) 掛載新節點
-->

---

# 修改 patch 和 mountElement

<div class="mt-6 grid grid-cols-2 gap-4">
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
    <div class="text-lg font-bold text-blue-300 mb-3">patch 函數</div>

```js {all}{lines:true}
function patch(n1, n2, container, anchor) {
  if (!n1) {
    // n1 為 null → 掛載
    mountElement(n2, container, anchor)
  } else {
    patchElement(n1, n2)
  }
}
```
  </div>

  <div v-click class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
    <div class="text-lg font-bold text-green-300 mb-3">mountElement 函數</div>

```js {all}{lines:true}
function mountElement(vnode, container, anchor) {
  const el = vnode.el = createElement(vnode.type)
  // ... 處理 children 和 props

  // 插入時使用錨點
  insert(el, container, anchor)
}
```
  </div>
</div>

<div v-click class="mt-6 bg-purple-900/20 border border-purple-500/30 rounded-lg p-4 text-center">
  <span class="text-purple-300 font-bold">關鍵：</span>
  <span class="text-gray-300">patch 第一個參數為 <code class="text-yellow-300">null</code> 表示新建</span>
</div>

<!--
修改 patch 和 mountElement：

patch 函數增加 anchor 參數，n1 為 null 時表示掛載新節點

[點擊] mountElement 函數也增加 anchor 參數，插入時使用錨點

[點擊] 關鍵：patch 第一個參數為 null 表示新建而非更新
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• <code class="text-yellow-300">find</code> 標誌識別新增節點</div>
    <div v-click="2">• 掛載到 <code class="text-blue-300">prevVNode.el.nextSibling</code> 前</div>
    <div v-click="3">• 第一個節點用 <code class="text-purple-300">container.firstChild</code></div>
  </div>
</div>

<!--
9.5 小結：

[點擊] find 標誌識別新增節點

[點擊] 掛載到 prevVNode.el.nextSibling 前

[點擊] 第一個節點用 container.firstChild 作為錨點
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div v-click class="text-4xl text-gray-300">
    現在我們會<span class="text-green-400 font-bold">移動</span>和<span class="text-blue-400 font-bold">新增</span>節點了
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold">
    但是...
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    如果舊節點在新 children 中<span class="text-red-400 font-bold">不存在</span>呢？
  </div>
</div>

<!--
接下來：

[點擊] 現在我們會移動和新增節點了

[點擊] 但是...

[點擊] 如果舊節點在新 children 中不存在呢？

這就是下一節 9.6 要討論的內容：移除不存在的元素
-->
