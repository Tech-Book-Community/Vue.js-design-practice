---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-green-400 mb-12">
    添加新元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    掛載在舊子節點中<br>
    <span class="text-yellow-300 font-bold">不存在</span>的新節點
  </div>
</div>

<!--
這一節我們來處理另一種情況：添加新元素。

[點擊] 什麼意思呢？就是當新的 children 裡面有一些節點，在舊的 children 裡面根本不存在，這些就是新增的節點，需要掛載到 DOM 上。
-->

---

# 問題：新節點不存在於舊 children

<div class="mt--4 scale-75">
  <NodesMapping
    :rows="[
      { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
      { newNode: 'p-2', index: 1 },
      { newNode: 'p-1', oldNode: 'p-3', index: 2, targetIndex: 0 },
      { newNode: 'p-4', index: 3 },
    ]"
  />
</div>

<div v-click class="mt--8 bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-yellow-300">
    <span class="text-green-400 font-bold">p-2</span> 和 <span class="text-green-400 font-bold">p-4</span> 在舊子節點中<span class="font-bold">不存在</span>，需要掛載（mount）
  </div>
</div>

<!--
來看這個例子。

舊的子節點只有兩個：p-1 和 p-3。
新的子節點有四個：p-3、p-2、p-1、p-4。

[點擊] 你會發現 p-2 和 p-4 在舊的列表裡面根本不存在。這種情況下，我們不是移動，而是要把這些新節點掛載上去。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    如何識別新增節點？
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed mb-8">
    使用 flag<br>
    <span class="text-yellow-300 font-bold font-mono text-5xl">find</span>
  </div>

  <div v-click class="text-2xl text-gray-400">
    遍歷完舊節點後<br>
    <code class="text-green-300">find === false</code> → 新增節點
  </div>
</div>

<!--
那要怎麼識別出哪些是新增的節點呢？

[點擊] 我們用一個 flag 變數叫做 find。

[點擊] 做法很簡單：一開始 find 設為 false，然後遍歷舊節點去找。如果找到相同 key 的，就把 find 設為 true。遍歷結束後，如果 find 還是 false，就代表這是一個新增的節點。
-->

---

# find flag

<div class="overflow-y-auto max-h-100 mt-4">

```js {all|3|7|13-14|all}{lines:true}
for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  let find = false // 初始化為 false

  for (let j = 0; j < oldChildren.length; j++) {
    if (newVNode.key === oldVNode.key) {
      find = true // 找到了！
      // ... patch 和移動邏輯
      break
    }
  }

  if (!find) {
    // 沒找到 → 新增節點，需要掛載
  }
}
```

</div>

<!--
來看程式碼怎麼寫。

[點擊] 在外層迴圈裡面，我們宣告一個 find 變數，初始值是 false。

[點擊] 接下來進入內層迴圈，如果找到相同 key 的舊節點，就把 find 設成 true，然後 break 跳出。

[點擊] 內層迴圈結束後，如果 find 還是 false，就代表這個新節點在舊的列表裡面找不到對應的，所以是一個新增的節點，需要掛載。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-purple-300 mb-12">
    新節點要掛載到哪裡？
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    前一個節點的後面
  </div>

  <div v-click class="text-2xl text-gray-300 font-mono">
    anchor = prevVNode.el.nextSibling
  </div>
</div>

<!--
好，那確定是新增節點之後，下一個問題是：要掛載到哪裡？

[點擊] 答案是：掛載到前一個節點的後面。

[點擊] 具體來說，就是取 prevVNode.el.nextSibling 作為錨點，然後用 insertBefore 把新節點插進去。
-->

---

# 確定掛載位置

<div class="mt-6">
  <div class="text-center text-sm text-gray-400 mb-4">新子節點：找到前一個節點作為參考</div>

  <div class="flex justify-center items-center gap-3">
    <!-- p-3 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div class="text-xs text-gray-500 mt-1">索引 0</div>
    </div>
    <!-- 箭頭指向 p-2 -->
    <div v-click="1" class="flex flex-col items-center">
      <div class="text-yellow-400 text-xs mb-1">prevVNode</div>
      <div class="text-2xl text-yellow-400">→</div>
    </div>
    <!-- p-2 (新增) -->
    <div v-click="2" class="text-center">
      <div class="w-14 h-10 bg-green-600 border-2 border-green-400 rounded flex items-center justify-center text-white text-sm font-bold">p-2</div>
      <div class="text-xs text-green-400 mt-1">新增!</div>
    </div>
    <!-- p-1 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div class="text-xs text-gray-500 mt-1">索引 2</div>
    </div>
    <!-- p-4 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-4</div>
      <div class="text-xs text-gray-500 mt-1">索引 3</div>
    </div>
  </div>

  <div v-click="1" class="mt-6 flex justify-center">
    <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4 text-center">
      <div class="text-blue-300 text-sm">
        p-2 的前一個節點是 <span class="text-yellow-300 font-bold">p-3</span><br>
        → 掛載到 <span class="text-yellow-300 font-mono">p-3.el.nextSibling</span> 前面
      </div>
    </div>
  </div>
</div>

<div v-click="3" class="mt-4 bg-green-900/20 border border-green-500/30 rounded-lg p-3">

```js
const prevVNode = newChildren[i - 1] // p-3
const anchor = prevVNode.el.nextSibling
patch(null, newVNode, container, anchor) // 掛載新節點
```
</div>

<!--
來看這個例子。

p-2 在新的子節點列表裡面，排在 p-3 後面，索引是 1。

[點擊] 所以 p-3 就是 p-2 的 prevVNode。我們要把 p-2 掛載到 p-3 對應的真實 DOM 後面。

[點擊] 這就是新增的 p-2。

[點擊] 程式碼就是這樣：取得 prevVNode，然後拿它的 el.nextSibling 當作錨點，再呼叫 patch。注意 patch 的第一個參數是 null，這代表是新建節點，不是更新。
-->

---

# 特殊情況：第一個節點是新增的

<div class="mt-6">
  <div class="text-center text-sm text-red-300 mb-4">問題：prevVNode 不存在怎麼辦？</div>

  <div class="flex justify-center items-center gap-3">
    <!-- p-4 (新增) - 第一個 -->
    <div v-click="2" class="text-center">
      <div class="w-14 h-10 bg-green-600 border-2 border-green-400 rounded flex items-center justify-center text-white text-sm font-bold">p-4</div>
      <div class="text-xs text-green-400 mt-1">新增!</div>
    </div>
    <!-- p-1 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div class="text-xs text-gray-500 mt-1">索引 1</div>
    </div>
    <!-- p-2 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-2</div>
      <div class="text-xs text-gray-500 mt-1">索引 2</div>
    </div>
    <!-- p-3 -->
    <div class="text-center">
      <div class="w-14 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div class="text-xs text-gray-500 mt-1">索引 3</div>
    </div>
  </div>

  <div class="mt-4 flex justify-center">
    <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
      <div class="text-red-300 text-sm">
        p-4 是第一個節點，<span class="text-red-400 font-bold">沒有前一個節點</span><br>
        prevVNode = <span class="text-red-400 font-mono">undefined</span> ❌
      </div>
    </div>
  </div>
</div>

<div v-click class="mt-4 grid grid-cols-2 gap-4">
  <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-3 text-center">
    <div class="text-green-300 text-sm mb-2">解決方案</div>
    <div class="text-yellow-300 font-mono text-sm">anchor = container.firstChild</div>
    <div class="text-gray-400 text-xs mt-1">插到容器最前面</div>
  </div>
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3">

```js
if (prevVNode) {
  anchor = prevVNode.el.nextSibling
}
else {
  anchor = container.firstChild
}
```
  </div>
</div>

<!--
不過這邊有一個特殊情況要處理。

如果新增的節點剛好是第一個，也就是索引是 0，那前面就沒有節點了，prevVNode 會是 undefined。

[點擊] 這時候怎麼辦？解決方案是：用 container.firstChild 當作錨點，把新節點插到容器的最前面。

程式碼就是這樣，先判斷 prevVNode 存不存在，再決定錨點要用哪個。
-->

---
clicks: 18
---

# 完整案例演示

<div class="mt-8"></div>

<DiffAnimationMount :clicks="$clicks" />

<!--
好，讓我們用動畫來看完整的案例。

舊的子節點是 [p-1, p-3]，新的是 [p-3, p-2, p-1, p-4]。

請點擊或按空格鍵逐步查看，動畫總共 18 步，會展示節點移動和新增的完整過程。
-->

---

# 完整實現程式碼

<div class="overflow-y-auto max-h-100 mt-2">

```js {all|3|14-27|all}{lines:true}
for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  let find = false

  for (let j = 0; j < oldChildren.length; j++) {
    if (newVNode.key === oldVNode.key) {
      find = true
      patch(oldVNode, newVNode, container)
      // ... 移動邏輯
      break
    }
  }

  // 如果 find 為 false，說明是新增節點
  if (!find) {
    const prevVNode = newChildren[i - 1]
    let anchor = null

    if (prevVNode) {
      anchor = prevVNode.el.nextSibling
    }
    else {
      anchor = container.firstChild
    }

    // 掛載新節點
    patch(null, newVNode, container, anchor)
  }
}
```

</div>

<!--
看完動畫之後，來看完整的程式碼。

[點擊] 這裡是 find flag，一開始設為 false。

[點擊] 這邊是重點：如果內層迴圈結束後 find 還是 false，就要處理新增節點。先看有沒有 prevVNode，有的話用它的 nextSibling，沒有的話用 container.firstChild。最後呼叫 patch，第一個參數傳 null，代表這是掛載新節點。
-->

---

# 修改 patch 和 mountElement

<div class="mt-6 grid grid-cols-2 gap-4">
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
    <div class="text-lg font-bold text-blue-300 mb-3">patch 函數</div>

```js {all}{lines:true}
function patch(n1, n2, container, anchor) {
  if (!n1) {
    // n1 為 null → 掛載
    mountElement(n2, container, anchor)
  }
  else {
    patchElement(n1, n2)
  }
}
```
  </div>

  <div v-click class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
    <div class="text-lg font-bold text-green-300 mb-3">mountElement 函數</div>

```js {all}{lines:true}
function mountElement(vnode, container, anchor) {
  const el = vnode.el = createElement(vnode.type)
  // ... 處理 children 和 props

  // 插入時使用錨點
  insert(el, container, anchor)
}
```
  </div>
</div>

<div v-click class="mt-6 bg-purple-900/20 border border-purple-500/30 rounded-lg p-4 text-center">
  <span class="text-purple-300 font-bold">關鍵：</span>
  <span class="text-gray-300">patch 第一個參數為 <code class="text-yellow-300">null</code> 表示新建</span>
</div>

<!--
為了支援這個功能，我們還需要修改 patch 和 mountElement 函數。

patch 函數要增加一個 anchor 參數。當 n1 是 null 的時候，就代表要掛載新節點，呼叫 mountElement。

[點擊] mountElement 函數也要增加 anchor 參數，在最後 insert 的時候使用這個錨點。

[點擊] 記住這個關鍵點：patch 的第一個參數如果是 null，就代表是新建節點，不是更新。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• <code class="text-yellow-300">find</code> 標誌識別新增節點</div>
    <div v-click="2">• 掛載到 <code class="text-blue-300">prevVNode.el.nextSibling</code> 前</div>
    <div v-click="3">• 第一個節點用 <code class="text-purple-300">container.firstChild</code></div>
  </div>
</div>

<!--
好，來做個小結。

[點擊] 第一，用 find flag 來識別新增節點。遍歷舊節點找不到對應的，find 就是 false。

[點擊] 第二，新節點要掛載到 prevVNode.el.nextSibling 前面。

[點擊] 第三，如果新節點是第一個，就用 container.firstChild 當錨點。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div v-click class="text-4xl text-gray-300">
    現在我們會<span class="text-green-400 font-bold">移動</span>和<span class="text-blue-400 font-bold">新增</span>節點了
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold">
    但是...
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    如果舊節點在新 children 中<span class="text-red-400 font-bold">不存在</span>呢？
  </div>
</div>

<!--
那到目前為止，我們已經學會兩件事了。

[點擊] 移動節點，還有新增節點。

[點擊] 但是還有一個問題...

[點擊] 如果舊的子節點裡面有些節點，在新的 children 裡面不存在呢？這些節點要怎麼處理？

這就是下一節 9.6 要討論的內容：移除不存在的元素。
-->
