# 加上 key 之後

<div class="grid grid-cols-2 gap-12 mt-8">
  <div>
    <div class="text-xl font-bold mb-4 text-blue-300">
      舊 children
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js{all|4|2|3|all}{at:2}
[
  { type: 'p', children: '1', key: 1 },
  { type: 'p', children: '2', key: 2 },
  { type: 'p', children: '3', key: 3 }
]
```
    </div>
  </div>

  <div>
    <div class="text-xl font-bold mb-4 text-green-300">
      新 children
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js{all|2|3|4|all}{at:2}
[
  { type: 'p', children: '3', key: 3 },
  { type: 'p', children: '1', key: 1 },
  { type: 'p', children: '2', key: 2 }
]
```
    </div>
  </div>
</div>

<div v-click class="mt-8">
  <div class="text-2xl font-bold text-green-400 mb-4 flex items-center justify-center">
    <div class="i-carbon-checkmark-outline mr-2 text-3xl"></div>
    現在清楚了！
  </div>
  <div class="text-lg text-gray-300 space-y-2">
    <div v-click="2">• 新 children 的第一個節點（<span class="font-mono text-green-300">key: 3</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第三個</span>節點</div>
    <div v-click="3">• 新 children 的第二個節點（<span class="font-mono text-green-300">key: 1</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第一個</span>節點</div>
    <div v-click="4">• 新 children 的第三個節點（<span class="font-mono text-green-300">key: 2</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第二個</span>節點</div>
  </div>
</div>

<!--
加上 key 之後：

舊 children 和新 children 都有 key 屬性了。

[點擊] 現在清楚了！
- 新 children 的第一個節點（key: 3）對應舊 children 的第三個節點
- 新 children 的第二個節點（key: 1）對應舊 children 的第一個節點
- 新 children 的第三個節點（key: 2）對應舊 children 的第二個節點
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-yellow-300 mb-20">
    key 屬性就像虛擬節點的 <span class="font-bold">"身份證字號"</span>
  </div>

  <div v-click class="text-3xl text-gray-300 mb-12">
    判斷兩個虛擬節點是否相同：
  </div>

  <div v-click class="space-y-8">
    <div class="text-5xl font-mono">
      <span class="text-blue-300">vnode1.type</span>
      <span class="text-gray-500 mx-4">===</span>
      <span class="text-blue-300">vnode2.type</span>
    </div>
    <div class="text-4xl text-gray-500">&&</div>
    <div class="text-5xl font-mono">
      <span class="text-green-300">vnode1.key</span>
      <span class="text-gray-500 mx-4">===</span>
      <span class="text-green-300">vnode2.key</span>
    </div>
  </div>
</div>

<!--
key 屬性就像虛擬節點的"身份證號"

[點擊] 判斷兩個虛擬節點是否相同：

[點擊] type 相同 且 key 相同
-->

---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-yellow-400 mb-12">
    <div class="i-carbon-warning-alt inline-block align-middle mr-3"></div>
    重要提醒
  </div>

  <div v-click class="text-4xl leading-relaxed mb-8">
    <span class="text-red-400 font-bold">DOM 復用</span>
    <span class="text-gray-400 mx-4">≠</span>
    <span class="text-red-400 font-bold">不需要更新</span>
  </div>

  <div v-click class="text-2xl text-gray-300">
    即使找到了相同 key 的節點<br>
    <span class="text-yellow-300 font-bold">仍然需要調用 patch 函數！</span>
  </div>
</div>

<!--
重要提醒：

[點擊] DOM 復用 不等於 不需要更新

[點擊] 即使找到了相同 key 的節點，仍然需要調用 patch 函數！
-->

---

# 為什麼要調用 patch？

<div class="grid grid-cols-2 gap-12 mt-8">
  <div>
    <div class="text-xl font-bold mb-4 text-blue-300">
      舊節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{ type: 'p', children: '1', key: 1 }
```
    </div>
  </div>

  <div>
    <div class="text-xl font-bold mb-4 text-green-300">
      新節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{ type: 'p', children: '100', key: 1 }
```
    </div>
  </div>
</div>

<div class="mt-12 space-y-6">
  <div v-click="1" class="p-6 bg-green-900/20 border-l-4 border-green-500">
    <div class="text-xl">
      ✅ <span class="font-mono text-green-300">type</span> 和 <span class="font-mono text-green-300">key</span> 都相同
      → 這是<span class="text-green-300 font-bold">同一個節點</span>
    </div>
  </div>
  <div v-click="2" class="p-6 bg-blue-900/20 border-l-4 border-blue-500">
    <div class="text-xl">
      ✅ DOM 元素可以<span class="text-blue-300 font-bold">復用</span>（不用卸載 <code class="bg-blue-800/30 px-2 py-1 rounded">&lt;p&gt;</code> 標籤再重新掛載）
    </div>
  </div>
  <div v-click="3" class="p-6 bg-yellow-900/20 border-l-4 border-yellow-500">
    <div class="text-xl">
      ⚠️ 但是 <span class="font-mono text-yellow-300">children</span> 從 <span class="font-mono text-red-300">'1'</span> 變成了 <span class="font-mono text-green-300">'100'</span>
      → <span class="text-yellow-300 font-bold">文字內容需要更新！</span>
    </div>
  </div>
</div>

<!--
讓我們看一個具體的例子：

舊節點和新節點的 type 都是 'p'，key 都是 1。

[點擊] type 和 key 都相同，所以這是同一個節點。

[點擊] DOM 元素可以復用，不用卸載 p 標籤再重新掛載。

[點擊] 但是！children 從 '1' 變成了 '100'，文字內容需要更新！
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 leading-relaxed">
    復用的是 <span class="text-blue-300 font-bold">DOM 元素本身</span>
  </div>

  <div class="text-3xl text-gray-400 my-8">但是</div>

  <div class="text-4xl text-gray-300 leading-relaxed">
    該元素的 <span class="text-yellow-300 font-bold">屬性和內容</span><br>
    仍然需要更新！
  </div>
</div>

<!--
總結一下：

復用的是 DOM 元素本身（比如 p 標籤），但該元素的屬性和內容仍然需要更新！

[點擊] 這就是為什麼程式碼中仍然要調用 patch 函數。
-->

---

# 實現程式碼

<div class="text-xl text-gray-300 mb-4">
有了 key 之後，我們可以改寫 patchChildren 函數
</div>

<div class="overflow-y-auto max-h-100">

```js {all|9-10|12-13|15-20|all}{lines:true}
function patchChildren(n1, n2, container) {
  if (typeof n2.children === 'string') {
    // 省略部分程式碼
  }
  else if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children

    // 遍歷新的 children
    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      // 遍歷舊的 children
      for (let j = 0; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]
        // 如果找到了具有相同 key 值的兩個節點，說明可以復用
        // 但仍然需要調用 patch 函數更新
        if (newVNode.key === oldVNode.key) {
          patch(oldVNode, newVNode, container)
          break // 找到後跳出內層循環
        }
      }
    }
  }
  else {
    // 省略部分程式碼
  }
}
```

</div>

<!--
有了 key 之後，我們可以改寫 patchChildren 函數：

[點擊] 遍歷新的 children

[點擊] 對每個新節點，遍歷舊的 children 查找

[點擊] 如果找到了具有相同 key 值的兩個節點，說明可以復用，但仍然需要調用 patch 函數更新，然後跳出內層循環

[點擊] 這就是核心思路：雙層循環查找、找到就 patch、break 跳出
-->

---

# 核心思路

<div class="grid grid-cols-3 gap-6 mt-12">
  <div v-click="1" class="p-6 bg-purple-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-search text-5xl mb-3 text-purple-300 mx-auto"></div>
      <div class="text-lg font-bold text-purple-300 mb-2">雙層循環查找</div>
      <div class="text-sm text-gray-300">
        遍歷新 children<br>
        在舊 children 中查找<br>
        相同 key 的節點
      </div>
    </div>
  </div>
  <div v-click="2" class="p-6 bg-blue-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-update-now text-5xl mb-3 text-blue-300 mx-auto"></div>
      <div class="text-lg font-bold text-blue-300 mb-2">找到就 patch</div>
      <div class="text-sm text-gray-300">
        如果 key 相同<br>
        說明可以復用<br>
        調用 patch 更新
      </div>
    </div>
  </div>
  <div v-click="3" class="p-6 bg-green-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-next-outline text-5xl mb-3 text-green-300 mx-auto"></div>
      <div class="text-lg font-bold text-green-300 mb-2">break 跳出</div>
      <div class="text-sm text-gray-300">
        找到對應節點後<br>
        跳出內層循環<br>
        繼續處理下一個新節點
      </div>
    </div>
  </div>
</div>

<!--
核心思路總結：

[點擊] 第一步：雙層循環查找 - 遍歷新 children，對每個新節點在舊 children 中查找相同 key 的節點

[點擊] 第二步：找到就 patch - 如果 key 相同，說明可以復用，調用 patch 更新

[點擊] 第三步：break 跳出 - 找到對應節點後跳出內層循環，繼續處理下一個新節點
-->

---
layout: center
---

<div class="text-center">
  <div v-click class="text-4xl text-gray-300 mb-12">
    現在我們可以確定哪些節點可以復用了
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    但要移動節點之前，得先知道<br>
    <span class="text-green-400 font-bold text-5xl">哪些節點需要移動？</span>
  </div>
</div>

<!--
[點擊] 現在我們可以確定哪些節點可以復用了。

[點擊] 但要移動節點之前，得先知道哪些節點需要移動？
-->
