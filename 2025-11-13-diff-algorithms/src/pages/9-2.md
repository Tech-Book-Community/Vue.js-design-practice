# 加上 key 之後

<div class="grid grid-cols-2 gap-12 mt-8">
  <div>
    <div class="text-xl font-bold mb-4 text-blue-300">
      舊 children
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js{all|4|2|3|all}{at:2}
[
  { type: 'p', children: '1', key: 1 },
  { type: 'p', children: '2', key: 2 },
  { type: 'p', children: '3', key: 3 }
]
```
    </div>
  </div>

  <div>
    <div class="text-xl font-bold mb-4 text-green-300">
      新 children
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js{all|2|3|4|all}{at:2}
[
  { type: 'p', children: '3', key: 3 },
  { type: 'p', children: '1', key: 1 },
  { type: 'p', children: '2', key: 2 }
]
```
    </div>
  </div>
</div>

<div v-click class="mt-8">
  <div class="text-2xl font-bold text-green-400 mb-4 flex items-center justify-center">
    <div class="i-carbon-checkmark-outline mr-2 text-3xl"></div>
    現在清楚了！
  </div>
  <div class="text-lg text-gray-300 space-y-2">
    <div v-click="2">• 新 children 的第一個節點（<span class="font-mono text-green-300">key: 3</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第三個</span>節點</div>
    <div v-click="3">• 新 children 的第二個節點（<span class="font-mono text-green-300">key: 1</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第一個</span>節點</div>
    <div v-click="4">• 新 children 的第三個節點（<span class="font-mono text-green-300">key: 2</span>）對應舊 children 的<span class="text-yellow-300 font-bold">第二個</span>節點</div>
  </div>
</div>

<!--
加上 key 之後就不一樣了！

你看，現在每個節點都有一個 key 屬性，像身分證號碼一樣。

[點擊] 現在對應關係就很清楚了！

新 children 的第一個節點 key 是 3，我們去舊 children 裡找 key 為 3 的，找到了，是第三個。
新 children 的第二個節點 key 是 1，對應舊 children 的第一個。
新 children 的第三個節點 key 是 2，對應舊 children 的第二個。

有了 key，不管順序怎麼變，我們都能準確配對！
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-yellow-300 mb-20">
    key 屬性就像虛擬節點的 <span class="font-bold">"身份證字號"</span>
  </div>

  <div v-click class="text-3xl text-gray-300 mb-12">
    判斷兩個虛擬節點是否相同：
  </div>

  <div v-click class="space-y-8">
    <div class="text-5xl font-mono">
      <span class="text-blue-300">vnode1.type</span>
      <span class="text-gray-500 mx-4">===</span>
      <span class="text-blue-300">vnode2.type</span>
    </div>
    <div class="text-4xl text-gray-500">&&</div>
    <div class="text-5xl font-mono">
      <span class="text-green-300">vnode1.key</span>
      <span class="text-gray-500 mx-4">===</span>
      <span class="text-green-300">vnode2.key</span>
    </div>
  </div>
</div>

<!--
所以我們可以這樣理解：key 屬性就像是虛擬節點的「身分證字號」。

[點擊] 那要怎麼判斷兩個虛擬節點是不是同一個呢？

[點擊] 答案是：type 要相同，而且 key 也要相同。兩個條件都滿足，我們才認為它們是同一個節點，可以復用。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-yellow-400 mb-12">
    <div class="i-carbon-warning-alt inline-block align-middle mr-3"></div>
    重要提醒
  </div>

  <div v-click class="text-4xl leading-relaxed mb-8">
    <span class="text-red-400 font-bold">DOM 復用</span>
    <span class="text-gray-400 mx-4">≠</span>
    <span class="text-red-400 font-bold">不需要更新</span>
  </div>

  <div v-click class="text-2xl text-gray-300">
    即使找到了相同 key 的節點<br>
    <span class="text-yellow-300 font-bold">仍然需要調用 patch 函數！</span>
  </div>
</div>

<!--
這裡有個重要的觀念要提醒大家：

[點擊] DOM 復用，不等於不需要更新！這兩件事是不一樣的。

[點擊] 即使我們找到了相同 key 的節點，確定可以復用，還是需要呼叫 patch 函數來更新它的內容！
-->

---

# 為什麼要調用 patch？

<div class="grid grid-cols-2 gap-12 mt-8">
  <div>
    <div class="text-xl font-bold mb-4 text-blue-300">
      舊節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{ type: 'p', children: '1', key: 1 }
```
    </div>
  </div>

  <div>
    <div class="text-xl font-bold mb-4 text-green-300">
      新節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{ type: 'p', children: '100', key: 1 }
```
    </div>
  </div>
</div>

<div class="mt-12 space-y-6">
  <div v-click="1" class="p-6 bg-green-900/20 border-l-4 border-green-500">
    <div class="text-xl">
      ✅ <span class="font-mono text-green-300">type</span> 和 <span class="font-mono text-green-300">key</span> 都相同
      → 這是<span class="text-green-300 font-bold">同一個節點</span>
    </div>
  </div>
  <div v-click="2" class="p-6 bg-blue-900/20 border-l-4 border-blue-500">
    <div class="text-xl">
      ✅ DOM 元素可以<span class="text-blue-300 font-bold">復用</span>（不用卸載 <code class="bg-blue-800/30 px-2 py-1 rounded">&lt;p&gt;</code> 標籤再重新掛載）
    </div>
  </div>
  <div v-click="3" class="p-6 bg-yellow-900/20 border-l-4 border-yellow-500">
    <div class="text-xl">
      ⚠️ 但是 <span class="font-mono text-yellow-300">children</span> 從 <span class="font-mono text-red-300">'1'</span> 變成了 <span class="font-mono text-green-300">'100'</span>
      → <span class="text-yellow-300 font-bold">文字內容需要更新！</span>
    </div>
  </div>
</div>

<!--
讓我用一個具體的例子來說明。

舊節點和新節點的 type 都是 'p'，key 都是 1。

[點擊] type 和 key 都相同，所以我們判斷這是同一個節點，可以復用。

[點擊] 「復用」的意思是：這個 p 標籤的 DOM 元素不用刪掉再重建，可以繼續用。

[點擊] 但是你看！children 從 '1' 變成了 '100'，內容變了啊！所以我們還是要呼叫 patch 來更新文字內容。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 leading-relaxed">
    復用的是 <span class="text-blue-300 font-bold">DOM 元素本身</span>
  </div>

  <div class="text-3xl text-gray-400 my-8">但是</div>

  <div class="text-4xl text-gray-300 leading-relaxed">
    該元素的 <span class="text-yellow-300 font-bold">屬性和內容</span><br>
    仍然需要更新！
  </div>
</div>

<!--
總結一下這個重要觀念：

我們復用的是 DOM 元素本身，比如那個 p 標籤。但是這個元素的屬性、內容這些東西，還是要更新的！

所以找到可復用節點之後，還是要呼叫 patch 函數來處理更新。
-->

---

# 實現程式碼

<div class="text-xl text-gray-300 mb-4">
有了 key 之後，我們可以改寫 patchChildren 函數
</div>

<div class="overflow-y-auto max-h-100">

```js {all|9-10|12-13|15-20|all}{lines:true}
function patchChildren(n1, n2, container) {
  if (typeof n2.children === 'string') {
    // 省略部分程式碼
  }
  else if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children

    // 遍歷新的 children
    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      // 遍歷舊的 children
      for (let j = 0; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]
        // 如果找到了具有相同 key 值的兩個節點，說明可以復用
        // 但仍然需要調用 patch 函數更新
        if (newVNode.key === oldVNode.key) {
          patch(oldVNode, newVNode, container)
          break // 找到後跳出內層循環
        }
      }
    }
  }
  else {
    // 省略部分程式碼
  }
}
```

</div>

<!--
好，有了 key 的概念之後，我們可以來改寫 patchChildren 函數了。

[點擊] 外層迴圈遍歷新的 children

[點擊] 內層迴圈遍歷舊的 children，去找有沒有相同 key 的節點

[點擊] 如果找到了相同 key 的節點，說明可以復用。我們呼叫 patch 函數來更新它，然後 break 跳出內層迴圈，繼續處理下一個新節點。

[點擊] 這就是核心思路：雙層迴圈查找配對，找到就 patch，然後 break。
-->

---

# 核心思路

<div class="grid grid-cols-3 gap-6 mt-12">
  <div v-click="1" class="p-6 bg-purple-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-search text-5xl mb-3 text-purple-300 mx-auto"></div>
      <div class="text-lg font-bold text-purple-300 mb-2">雙層循環查找</div>
      <div class="text-sm text-gray-300">
        遍歷新 children<br>
        在舊 children 中查找<br>
        相同 key 的節點
      </div>
    </div>
  </div>
  <div v-click="2" class="p-6 bg-blue-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-update-now text-5xl mb-3 text-blue-300 mx-auto"></div>
      <div class="text-lg font-bold text-blue-300 mb-2">找到就 patch</div>
      <div class="text-sm text-gray-300">
        如果 key 相同<br>
        說明可以復用<br>
        調用 patch 更新
      </div>
    </div>
  </div>
  <div v-click="3" class="p-6 bg-green-900/20 rounded-lg">
    <div class="text-center">
      <div class="i-carbon-next-outline text-5xl mb-3 text-green-300 mx-auto"></div>
      <div class="text-lg font-bold text-green-300 mb-2">break 跳出</div>
      <div class="text-sm text-gray-300">
        找到對應節點後<br>
        跳出內層循環<br>
        繼續處理下一個新節點
      </div>
    </div>
  </div>
</div>

<!--
讓我用三張卡片來總結核心思路：

[點擊] 第一步：雙層迴圈查找。外層遍歷新 children，內層在舊 children 中找相同 key 的節點。

[點擊] 第二步：找到就 patch。key 相同代表可以復用，呼叫 patch 來更新內容。

[點擊] 第三步：break 跳出。找到配對之後就跳出內層迴圈，繼續處理下一個新節點。
-->

---
layout: center
---

<div class="text-center">
  <div v-click class="text-4xl text-gray-300 mb-12">
    現在我們可以確定哪些節點可以復用了
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    但要移動節點之前，得先知道<br>
    <span class="text-green-400 font-bold text-5xl">哪些節點需要移動？</span>
  </div>
</div>

<!--
[點擊] 好，現在我們已經可以透過 key 來找出哪些節點可以復用了。

[點擊] 但是還有一個問題：我們知道哪些節點可以復用，但要怎麼知道哪些節點需要「移動」呢？這就是下一節要討論的內容。
-->
