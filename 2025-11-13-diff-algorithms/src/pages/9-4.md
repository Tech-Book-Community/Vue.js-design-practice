---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-purple-400 mb-12">
    如何移動元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    通過 <span class="text-green-400 font-bold font-mono">insertBefore</span><br>
    移動真實 DOM
  </div>
</div>

<!--
這一節我們來解決「如何移動元素」這個問題。

[點擊] 答案是：透過瀏覽器提供的 insertBefore API 來移動真實的 DOM 元素。
-->

---

# 前提條件：vnode.el

<div class="mt-8 space-y-8">
  <div class="text-2xl text-yellow-300 text-center">
    每個虛擬節點通過 <code class="bg-yellow-800/30 px-3 py-1 rounded">vnode.el</code> 引用其對應的真實 DOM
  </div>
  <div class="grid grid-cols-2 gap-6 mt-8">
    <div v-click="1" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
      <div class="text-lg font-bold text-blue-300 mb-3">掛載時建立引用</div>
```js
vnode.el = document.createElement('p')
container.appendChild(vnode.el)
// 現在 vnode.el 指向真實 DOM
```
    </div>
    <div v-click="2" class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
      <div class="text-lg font-bold text-green-300 mb-3">更新時傳遞引用</div>
```js
function patchElement(n1, n2) {
  const el = n2.el = n1.el
  // 新 vnode 也引用同一個 DOM
}
```
    </div>
  </div>
  <div v-click="3" class="text-xl text-gray-300 text-center mt-6">
    有了這個引用，就能透過 <code class="text-green-300">newVNode.el</code> 拿到需要移動的 DOM
  </div>
</div>

<!--
但在講移動之前，有一個前提條件要先了解：vnode.el。

每個虛擬節點都有一個 el 屬性，它指向對應的真實 DOM 元素。

[點擊] 這個引用是在掛載的時候建立的。當我們用 createElement 建立 DOM 後，就把它存到 vnode.el。

[點擊] 在更新的時候，我們會把這個引用傳遞給新的 vnode，讓新舊 vnode 指向同一個 DOM。

[點擊] 有了這個引用，我們就能透過 newVNode.el 拿到需要移動的那個真實 DOM 元素了。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    移動原則
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    新 children 的順序<br>
    <span class="text-5xl">=</span><br>
    更新後 DOM 的順序
  </div>

  <div v-click class="text-2xl text-gray-300 leading-relaxed">
    節點在新 children 中的位置<br>
    就是它對應的真實 DOM 應該在的位置
  </div>
</div>

<!--
接下來講移動的原則。

[點擊] 核心概念是：新 children 的順序，就是我們希望更新後 DOM 的順序。

[點擊] 換句話說，一個節點在新 children 中排第幾，它對應的真實 DOM 就應該排第幾。我們的目標就是把 DOM 調整成跟新 children 一樣的順序。
-->

---

# 移動策略

<div class="mt-8 space-y-6">
  <div v-click="1" class="bg-purple-900/20 border border-purple-500/30 rounded-lg p-5">
    <div class="text-xl text-purple-300 mb-3">情境</div>
    <div class="text-lg text-gray-300">
      如果 p-1 在新 children 中排在 p-3 <span class="text-yellow-300 font-bold">後面</span><br>
      → 把 p-1 的真實 DOM 移動到 p-3 的真實 DOM <span class="text-yellow-300 font-bold">後面</span>
    </div>
  </div>

  <div v-click="2" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">
    <div class="text-xl text-blue-300 mb-3">具體步驟</div>
    <div class="space-y-3 text-lg">
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">1</span>
        <span>獲取當前節點的前一個節點 <code class="text-green-300">prevVNode</code></span>
      </div>
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">2</span>
        <span>獲取 <code class="text-green-300">prevVNode.el.nextSibling</code> 作為錨點</span>
      </div>
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">3</span>
        <span>將當前節點插入到錨點前面</span>
      </div>
    </div>
  </div>
</div>

<!--
那具體要怎麼移動呢？來看移動策略。

[點擊] 情境是這樣的：假設 p-1 在新 children 中排在 p-3 的後面，那我們就要把 p-1 的真實 DOM 移動到 p-3 的真實 DOM 後面。

[點擊] 具體步驟分三步：
第一步，找到當前節點的前一個節點，我們叫它 prevVNode。
第二步，取得 prevVNode.el.nextSibling 作為錨點。
第三步，把當前節點插入到這個錨點的前面。

這樣就能把節點移到正確的位置了。
-->

---
clicks: 14
---

# 完整案例演示

<div class="mt-12"></div>

<DiffAnimationMove :clicks="$clicks" />

<!--
現在讓我們用一個完整的案例來演示整個流程。

舊的 children 是 p-1、p-2、p-3，新的 children 是 p-3、p-1、p-2。

這個動畫會展示：
- 怎麼用 lastIndex 判斷哪些節點需要移動
- 怎麼用 prevVNode.el.nextSibling 找到錨點
- 怎麼執行實際的移動操作

大家可以按空格鍵或點擊來一步步看，總共 14 個步驟。
-->

---

# 實現程式碼

<div class="overflow-y-auto max-h-100">

````md magic-move
```js {all|4-5|7-9|10-11|all}{lines:true}
if (j < lastIndex) {
  // 程式碼運行到這裡，說明 newVNode 對應的真實 DOM 需要移動

  // 獲取 newVNode 的前一個 vnode
  const prevVNode = newChildren[i - 1]

  if (prevVNode) {
    // 獲取 prevVNode 的下一個兄弟節點作為錨點
    const anchor = prevVNode.el.nextSibling
    // 將 newVNode 對應的真實 DOM 插入到錨點前面
    insert(newVNode.el, container, anchor)
  }
} else {
  lastIndex = j
}
```
```js {all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children
    let lastIndex = 0
    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      let j = 0
      for (let j; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]
        if (newVNode.key === oldVNode.key) {
          patch(oldVNode, newVNode, container)
          if (j < lastIndex) {
            const prevVNode = newChildren[i - 1]

            if (prevVNode) {
              const anchor = prevVNode.el.nextSibling
              insert(newVNode.el, container, anchor)
            }
          } else {
            lastIndex = j
          }
          break
        }
      }
    }
  }
}
```
````

</div>

<!--
來看實現程式碼。

[點擊] 首先，取得 newVNode 的前一個 vnode，也就是 newChildren[i - 1]。

[點擊] 如果 prevVNode 存在，我們就取它的 el.nextSibling 作為錨點，然後呼叫 insert 把當前節點插入到錨點前面。

[點擊] insert 函數會呼叫瀏覽器的 insertBefore API 來執行實際的 DOM 移動。

[點擊] 右邊是完整的 patchChildren 函數，包含了所有的邏輯。
-->

---

# insert 函數

<div class="mt-8 space-y-6">
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">

```js
const renderer = createRenderer({
  // 省略程式碼

  insert(el, parent, anchor = null) {
    parent.insertBefore(el, anchor)
  }
})
```
  </div>

  <div v-click="1" class="grid grid-cols-2 gap-4">
    <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
      <div class="text-green-300 font-bold mb-2">anchor 為 null</div>
      <div class="text-gray-300 text-sm">等同於 appendChild，插入到末尾</div>
    </div>
    <div class="bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-4">
      <div class="text-yellow-300 font-bold mb-2">anchor 不為 null</div>
      <div class="text-gray-300 text-sm">插入到 anchor 之前</div>
    </div>
  </div>

  <div v-click="2" class="bg-purple-900/20 border border-purple-500/30 rounded-lg p-4 text-center">
    <span class="text-purple-300 font-bold">關鍵點：</span>
    <span class="text-gray-300">insertBefore 不僅可以插入新元素，也可以<span class="text-yellow-300 font-bold">移動</span>已存在的元素</span>
  </div>
</div>

<!--
來看一下 insert 函數的實現。

它其實就是對 insertBefore 的一層封裝。

[點擊] insertBefore 有個特性：
如果 anchor 是 null，它的行為就跟 appendChild 一樣，會插入到最後面。
如果 anchor 不是 null，就會插入到 anchor 的前面。

[點擊] 還有一個重要的特性：insertBefore 不只能插入新元素，它也可以移動已經存在的元素！當你把一個已經在 DOM 中的元素插入到另一個位置，它會自動從原本的位置移走。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• <code class="text-yellow-300">vnode.el</code> 引用真實 DOM</div>
    <div v-click="2">• 新 children 順序 = 目標 DOM 順序</div>
    <div v-click="3">• 移動到 <code class="text-blue-300">prevVNode.el.nextSibling</code> 前面</div>
    <div v-click="4">• <code class="text-purple-300">insertBefore</code> 可移動已存在元素</div>
  </div>
</div>

<!--
來做個小結。

[點擊] 第一，vnode.el 這個屬性讓我們能夠從虛擬節點找到對應的真實 DOM。

[點擊] 第二，新 children 的順序就是我們要達成的目標 DOM 順序。

[點擊] 第三，移動的方式是把節點插入到 prevVNode.el.nextSibling 的前面。

[點擊] 第四，insertBefore 這個 API 可以移動已經存在的元素，不只是插入新的。
-->
