---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-purple-400 mb-12">
    如何移動元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    通過 <span class="text-green-400 font-bold font-mono">insertBefore</span><br>
    移動真實 DOM
  </div>
</div>

<!--
9.4 如何移動元素

[點擊] 通過 insertBefore 移動真實 DOM
-->

---

# 前提條件：vnode.el

<div class="mt-8 space-y-8">
  <div class="text-2xl text-yellow-300 text-center">
    每個虛擬節點通過 <code class="bg-yellow-800/30 px-3 py-1 rounded">vnode.el</code> 引用其對應的真實 DOM
  </div>
  <div class="grid grid-cols-2 gap-6 mt-8">
    <div v-click="1" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
      <div class="text-lg font-bold text-blue-300 mb-3">掛載時建立引用</div>
```js
vnode.el = document.createElement('p')
container.appendChild(vnode.el)
// 現在 vnode.el 指向真實 DOM
```
    </div>
    <div v-click="2" class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
      <div class="text-lg font-bold text-green-300 mb-3">更新時傳遞引用</div>
```js
function patchElement(n1, n2) {
  const el = n2.el = n1.el
  // 新 vnode 也引用同一個 DOM
}
```
    </div>
  </div>
  <div v-click="3" class="text-xl text-gray-300 text-center mt-6">
    有了這個引用，就能透過 <code class="text-green-300">newVNode.el</code> 拿到需要移動的 DOM
  </div>
</div>

<!--
前提條件：vnode.el

每個虛擬節點通過 vnode.el 引用其對應的真實 DOM

[點擊] 掛載時建立引用 - createElement 後賦值給 vnode.el

[點擊] 更新時傳遞引用 - 新 vnode 也引用同一個 DOM

[點擊] 有了這個引用，就能透過 newVNode.el 拿到需要移動的 DOM
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    移動原則
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    新 children 的順序<br>
    <span class="text-5xl">=</span><br>
    更新後 DOM 的順序
  </div>

  <div v-click class="text-2xl text-gray-300 leading-relaxed">
    節點在新 children 中的位置<br>
    就是它對應的真實 DOM 應該在的位置
  </div>
</div>

<!--
移動原則：

[點擊] 新 children 的順序 = 更新後 DOM 的順序

[點擊] 節點在新 children 中的位置，就是它對應的真實 DOM 應該在的位置
-->

---

# 移動策略

<div class="mt-8 space-y-6">
  <div v-click="1" class="bg-purple-900/20 border border-purple-500/30 rounded-lg p-5">
    <div class="text-xl text-purple-300 mb-3">情境</div>
    <div class="text-lg text-gray-300">
      如果 p-1 在新 children 中排在 p-3 <span class="text-yellow-300 font-bold">後面</span><br>
      → 把 p-1 的真實 DOM 移動到 p-3 的真實 DOM <span class="text-yellow-300 font-bold">後面</span>
    </div>
  </div>

  <div v-click="2" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">
    <div class="text-xl text-blue-300 mb-3">具體步驟</div>
    <div class="space-y-3 text-lg">
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">1</span>
        <span>獲取當前節點的前一個節點 <code class="text-green-300">prevVNode</code></span>
      </div>
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">2</span>
        <span>獲取 <code class="text-green-300">prevVNode.el.nextSibling</code> 作為錨點</span>
      </div>
      <div class="flex items-center">
        <span class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm mr-3">3</span>
        <span>將當前節點插入到錨點前面</span>
      </div>
    </div>
  </div>
</div>

<!--
移動策略：

[點擊] 情境：如果 p-1 在新 children 中排在 p-3 後面，那就把 p-1 的真實 DOM 移動到 p-3 的真實 DOM 後面

[點擊] 具體步驟：
1. 獲取當前節點的前一個節點 prevVNode
2. 獲取 prevVNode.el.nextSibling 作為錨點
3. 將當前節點插入到錨點前面
-->

---
clicks: 14
---

# 完整案例演示

<div class="mt-12"></div>

<DiffAnimationMove :clicks="$clicks" />

<!--
完整案例演示

案例：[p-1, p-2, p-3] → [p-3, p-1, p-2]

請點擊或按空格鍵逐步查看動畫演示

（動畫共 14 步，展示完整的 Diff 過程）
-->

---

# 實現代碼

<div class="overflow-y-auto max-h-100">

````md magic-move
```js {all|4-5|7-9|10-11|all}{lines:true}
if (j < lastIndex) {
  // 代碼運行到這裡，說明 newVNode 對應的真實 DOM 需要移動

  // 獲取 newVNode 的前一個 vnode
  const prevVNode = newChildren[i - 1]

  if (prevVNode) {
    // 獲取 prevVNode 的下一個兄弟節點作為錨點
    const anchor = prevVNode.el.nextSibling
    // 將 newVNode 對應的真實 DOM 插入到錨點前面
    insert(newVNode.el, container, anchor)
  }
} else {
  lastIndex = j
}
```
```js {all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children
    let lastIndex = 0
    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      let j = 0
      for (let j; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]
        if (newVNode.key === oldVNode.key) {
          patch(oldVNode, newVNode, container)
          if (j < lastIndex) {
            const prevVNode = newChildren[i - 1]
          
            if (prevVNode) {
              const anchor = prevVNode.el.nextSibling
              insert(newVNode.el, container, anchor)
            }
          } else {
            lastIndex = j
          }
          break
        }
      }
    }
  }
}
```
````

</div>

<!--
實現代碼：

[點擊] 獲取 newVNode 的前一個 vnode

[點擊] 如果 prevVNode 存在，獲取它的下一個兄弟節點作為錨點，然後插入

[點擊] insert 函數負責實際的 DOM 移動

[點擊] 這就是完整的移動邏輯
-->

---

# insert 函數

<div class="mt-8 space-y-6">
  <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">

```js
const renderer = createRenderer({
  // 省略程式碼

  insert(el, parent, anchor = null) {
    parent.insertBefore(el, anchor)
  }
})
```
  </div>

  <div v-click="1" class="grid grid-cols-2 gap-4">
    <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-4">
      <div class="text-green-300 font-bold mb-2">anchor 為 null</div>
      <div class="text-gray-300 text-sm">等同於 appendChild，插入到末尾</div>
    </div>
    <div class="bg-yellow-900/20 border border-yellow-500/30 rounded-lg p-4">
      <div class="text-yellow-300 font-bold mb-2">anchor 不為 null</div>
      <div class="text-gray-300 text-sm">插入到 anchor 之前</div>
    </div>
  </div>

  <div v-click="2" class="bg-purple-900/20 border border-purple-500/30 rounded-lg p-4 text-center">
    <span class="text-purple-300 font-bold">關鍵點：</span>
    <span class="text-gray-300">insertBefore 不僅可以插入新元素，也可以<span class="text-yellow-300 font-bold">移動</span>已存在的元素</span>
  </div>
</div>

<!--
insert 函數：

基於 insertBefore 的封裝

[點擊] 
- anchor 為 null 時，等同於 appendChild，插入到末尾
- anchor 不為 null 時，插入到 anchor 之前

[點擊] 關鍵點：insertBefore 不僅可以插入新元素，也可以移動已存在的元素
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• <code class="text-yellow-300">vnode.el</code> 引用真實 DOM</div>
    <div v-click="2">• 新 children 順序 = 目標 DOM 順序</div>
    <div v-click="3">• 移動到 <code class="text-blue-300">prevVNode.el.nextSibling</code> 前面</div>
    <div v-click="4">• <code class="text-purple-300">insertBefore</code> 可移動已存在元素</div>
  </div>
</div>

<!--
9.4 小結：

[點擊] vnode.el 引用真實 DOM

[點擊] 新 children 順序 = 目標 DOM 順序

[點擊] 移動到 prevVNode.el.nextSibling 前面

[點擊] insertBefore 可移動已存在元素
-->
