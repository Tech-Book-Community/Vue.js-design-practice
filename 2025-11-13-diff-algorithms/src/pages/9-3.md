---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    <div class="i-carbon-idea text-5xl inline-block align-middle mr-3"></div>
    逆向思維
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed mb-8">
    先想想：
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold leading-relaxed">
    什麼情況下<br>
    節點<span class="text-green-400">不需要</span>移動？
  </div>
</div>

<!--
讓我們用逆向思維來思考：

[點擊] 先想想：

[點擊] 什麼情況下節點不需要移動？
-->

---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-green-400 leading-relaxed">
    當新舊兩組子節點的<br>
    <span class="text-6xl">順序不變</span>時<br>
    就不需要移動！
  </div>
</div>

<!--
答案：當新舊兩組子節點的順序不變時，就不需要移動！
-->

---

# 情況 1：順序不變

<div class="mt-4">
  <div class="flex items-center justify-center scale-95">
    <NodesMapping
      :rows="[
        { newNode: 'p-1', oldNode: 'p-1', index: 0 },
        { newNode: 'p-2', oldNode: 'p-2', index: 1 },
        { newNode: 'p-3', oldNode: 'p-3', index: 2 },
      ]"
    />
  </div>

  <div v-click="1" class="mt-4 space-y-3">
    <div class="text-lg text-gray-300">查找過程中記錄的索引：</div>
    <div class="grid grid-cols-3 gap-3">
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-1</div>
        <div class="text-2xl font-bold text-blue-400 my-1">0</div>
      </div>
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-2</div>
        <div class="text-2xl font-bold text-blue-400 my-1">1</div>
      </div>
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-3</div>
        <div class="text-2xl font-bold text-blue-400 my-1">2</div>
      </div>
    </div>
  </div>
</div>

<!--
情況 1：順序不變，不需要移動

舊子節點是 p-1, p-2, p-3，新子節點也是 p-1, p-2, p-3

[點擊] 遍歷新子節點，依次查找它們在舊子節點中的位置：
- p-1 在索引 0
- p-2 在索引 1
- p-3 在索引 2

[點擊] 索引序列是遞增的（0 → 1 → 2），這說明順序沒有改變，不需要移動任何節點。
-->

---

# 情況 2：順序改變

<div class="mt-4">
  <div class="flex justify-center scale-95">
    <div class="w-2/4">
      <NodesMapping
        :rows="[
          { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
          { newNode: 'p-1', oldNode: 'p-2', index: 1, targetIndex: 0 },
          { newNode: 'p-2', oldNode: 'p-3', index: 2, targetIndex: 1 },
        ]"
      />
    </div>
  </div>

  <div v-click="1" class="mt--12 space-y-3">
    <div class="text-lg text-gray-300">查找過程中記錄的索引：</div>
    <div class="grid grid-cols-3 gap-3">
      <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-3 text-center">
        <div class="text-green-300 font-mono">p-3</div>
        <div class="text-2xl font-bold text-green-400 my-1">2</div>
      </div>
      <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
        <div class="text-red-300 font-mono">p-1</div>
        <div class="text-2xl font-bold text-red-400 my-1">0</div>
        <div class="text-xs text-red-300">比前面的 2 小！</div>
      </div>
      <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
        <div class="text-red-300 font-mono">p-2</div>
        <div class="text-2xl font-bold text-red-400 my-1">1</div>
        <div class="text-xs text-red-300">比前面的 2 小！</div>
      </div>
    </div>
  </div>
</div>

<!--
情況 2：順序改變，需要移動

舊子節點是 p-1, p-2, p-3，新子節點是 p-3, p-1, p-2，順序完全不同

[點擊] 查找過程中記錄的索引：
- p-3 在索引 2
- p-1 在索引 0（比前面的 2 小！）
- p-2 在索引 1（比前面的 2 小！）

[點擊] 索引序列不是遞增的（2 → 0 → 1），這說明順序改變了，p-1 和 p-2 需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-3xl text-gray-300 mb-8">
    核心規則
  </div>

  <div class="text-4xl text-yellow-300 leading-loose">
    如果在遍歷新子節點的過程中<br>
    發現某個節點在舊子節點中的索引<br>
    <span class="text-red-400 font-bold text-5xl">比前面的節點索引小</span><br>
    那麼這個節點就需要移動
  </div>
</div>

<!--
從上面的觀察中，我們可以得出核心規則：

如果在遍歷新子節點的過程中，發現某個節點在舊子節點中的索引比前面的節點索引小，那麼這個節點就需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 mb-12">
    為了實現這個規則<br>
    我們需要一個變量
  </div>

  <div v-click class="text-8xl font-bold font-mono mb-12">
    <span class="text-purple-400">lastIndex</span>
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed">
    記錄當前遇到的<br>
    <span class="text-yellow-300 font-bold text-4xl">最大索引值</span>
  </div>
</div>

<!--
為了實現這個規則，我們需要一個變量

[點擊] lastIndex

[點擊] 記錄當前遇到的最大索引值
-->

---

# lastIndex 的判斷邏輯

<div class="overflow-y-auto max-h-100 mt-6">

```js {all|1|5-6|10|13-15|16-20|all}{lines:true}
let lastIndex = 0 // 初始化為 0

for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  // 遍歷舊的 children
  for (let j = 0; j < oldChildren.length; j++) {
    const oldVNode = oldChildren[j]

    if (newVNode.key === oldVNode.key) {
      // 找到可復用節點，j 是它在舊 children 中的索引

      // 🔑 關鍵判斷
      if (j < lastIndex) {
        // 當前索引 < 最大索引 → 需要移動
        console.log(`節點 ${newVNode.key} 需要移動`)
      }
      else {
        // 當前索引 >= 最大索引 → 不需要移動
        // 更新 lastIndex
        lastIndex = j
      }

      break
    }
  }
}
```

</div>

<!--
lastIndex 的判斷邏輯：

[點擊] 初始化 lastIndex 為 0

[點擊] 遍歷舊的 children

[點擊] 找到可復用節點，j 是它在舊 children 中的索引

[點擊] 關鍵判斷來了

[點擊] 如果 j 小於 lastIndex，說明當前索引比最大索引小，需要移動

[點擊] 否則不需要移動，並更新 lastIndex 為 j

[點擊] 這就是完整的判斷邏輯
-->

---

# 實現程式碼

<div class="overflow-y-auto max-h-100 mt-4">

```js {all|6|10-11|15-16|18-26|all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children

    let lastIndex = 0 // 記錄遇到的最大索引值

    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      // 遍歷舊的 children
      for (let j = 0; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]

        if (newVNode.key === oldVNode.key) {
          // 先調用 patch 函數進行更新
          patch(oldVNode, newVNode, container)

          // 判斷是否需要移動
          if (j < lastIndex) {
            // 需要移動（具體如何移動下一節講解）
            console.log(`節點 ${newVNode.key} 需要移動`)
          }
          else {
            // 不需要移動，更新 lastIndex
            lastIndex = j
          }

          break
        }
      }
    }
  }
}
```

</div>

<!--
最後來看實現程式碼：

[點擊] 初始化 lastIndex 為 0，用來記錄遇到的最大索引值

[點擊] 遍歷舊的 children

[點擊] 先調用 patch 函數進行打補丁（這一步很重要！）

[點擊] 然後判斷是否需要移動：
- 如果 j < lastIndex，需要移動
- 否則不需要移動，更新 lastIndex

[點擊] 這就是完整的實現程式碼
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-yellow-300 font-bold">
    lastIndex 的作用
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed">
    • 始終存儲著<span class="text-blue-300 font-bold">當前遇到的最大索引值</span><br>
    • 用於判斷<span class="text-green-300 font-bold">後續節點是否需要移動</span><br>
    • 如果後續節點的索引 &lt; lastIndex<br>
    說明<span class="text-red-300 font-bold">順序改變了，需要移動</span>
  </div>
</div>

<!--
關鍵點總結 - lastIndex 的作用：

[點擊]
- 始終存儲著當前遇到的最大索引值
- 用於判斷後續節點是否需要移動
- 如果後續節點的索引比 lastIndex 小，說明順序改變了，需要移動
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div v-click class="text-4xl text-gray-300">
    為什麼這個方法有效？
  </div>

  <div v-click class="text-3xl text-gray-300 leading-loose px-12">
    因為如果新舊子節點的<span class="text-blue-300 font-bold">順序相同</span><br>
    那麼在遍歷新子節點的過程中<br>
    找到的對應舊節點的索引應該是<span class="text-green-300 font-bold text-4xl">遞增的</span>
  </div>

  <div v-click class="text-3xl text-yellow-300 leading-loose px-12">
    如果索引不是遞增的<br>
    就說明<span class="text-red-300 font-bold">順序改變了，需要移動</span>
  </div>
</div>

<!--
為什麼這個方法有效？

[點擊] 為什麼這個方法有效？

[點擊] 因為如果新舊子節點的順序相同，那麼在遍歷新子節點的過程中，找到的對應舊節點的索引應該是遞增的。

[點擊] 如果索引不是遞增的（即當前索引 < lastIndex），就說明順序改變了，需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div v-click class="text-4xl text-gray-300 mb-12">
    現在我們知道了<br>
    <span class="text-green-400 font-bold">如何判斷節點需要移動</span>
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold mb-12">
    但是...
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    具體要怎麼移動這些節點呢？<br>
    <span class="text-purple-400 font-bold">移動到哪裡？</span>
  </div>
</div>

<!--
接下來：

[點擊] 現在我們知道了如何判斷節點需要移動

[點擊] 但是...

[點擊] 具體要怎麼移動這些節點呢？移動到哪裡？

這就是下一節 9.4 要討論的內容：如何移動元素。
-->
