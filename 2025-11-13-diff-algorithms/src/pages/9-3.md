---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-blue-300 mb-12">
    <div class="i-carbon-idea text-5xl inline-block align-middle mr-3"></div>
    逆向思維
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed mb-8">
    先想想：
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold leading-relaxed">
    什麼情況下<br>
    節點<span class="text-green-400">不需要</span>移動？
  </div>
</div>

<!--
要回答「哪些節點需要移動」這個問題，讓我們換個角度來思考。

[點擊] 與其問「什麼時候要移動」，不如先問：

[點擊] 什麼情況下節點「不需要」移動？把這個搞清楚，剩下的就是需要移動的了。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-green-400 leading-relaxed">
    當新舊兩組子節點的<br>
    <span class="text-6xl">順序不變</span>時<br>
    就不需要移動！
  </div>
</div>

<!--
答案很直觀：當新舊兩組子節點的「順序沒變」的時候，就不需要移動！

順序一樣，位置就對了，何必移動呢？
-->

---

# 情況 1：順序不變

<div class="mt-4">
  <div class="flex items-center justify-center scale-95">
    <NodesMapping
      :rows="[
        { newNode: 'p-1', oldNode: 'p-1', index: 0 },
        { newNode: 'p-2', oldNode: 'p-2', index: 1 },
        { newNode: 'p-3', oldNode: 'p-3', index: 2 },
      ]"
    />
  </div>

  <div v-click="1" class="mt-4 space-y-3">
    <div class="text-lg text-gray-300">查找過程中記錄的索引：</div>
    <div class="grid grid-cols-3 gap-3">
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-1</div>
        <div class="text-2xl font-bold text-blue-400 my-1">0</div>
      </div>
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-2</div>
        <div class="text-2xl font-bold text-blue-400 my-1">1</div>
      </div>
      <div class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-3 text-center">
        <div class="text-blue-300 font-mono">p-3</div>
        <div class="text-2xl font-bold text-blue-400 my-1">2</div>
      </div>
    </div>
  </div>
</div>

<!--
來看情況一：順序不變，不需要移動。

舊子節點是 p-1、p-2、p-3，新子節點也是 p-1、p-2、p-3，順序完全一樣。

[點擊] 我們遍歷新子節點，去舊子節點裡面找它們的位置：
p-1 在舊列表的索引 0
p-2 在舊列表的索引 1
p-3 在舊列表的索引 2

你會發現，我們找到的索引序列是 0、1、2，是遞增的！

這代表什麼？代表順序沒有改變，所以不需要移動任何節點。
-->

---

# 情況 2：順序改變

<div class="mt-4">
  <div class="flex justify-center scale-95">
    <div class="w-2/4">
      <NodesMapping
        :rows="[
          { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
          { newNode: 'p-1', oldNode: 'p-2', index: 1, targetIndex: 0 },
          { newNode: 'p-2', oldNode: 'p-3', index: 2, targetIndex: 1 },
        ]"
      />
    </div>
  </div>

  <div v-click="1" class="mt--12 space-y-3">
    <div class="text-lg text-gray-300">查找過程中記錄的索引：</div>
    <div class="grid grid-cols-3 gap-3">
      <div class="bg-green-900/20 border border-green-500/30 rounded-lg p-3 text-center">
        <div class="text-green-300 font-mono">p-3</div>
        <div class="text-2xl font-bold text-green-400 my-1">2</div>
      </div>
      <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
        <div class="text-red-300 font-mono">p-1</div>
        <div class="text-2xl font-bold text-red-400 my-1">0</div>
        <div class="text-xs text-red-300">比前面的 2 小！</div>
      </div>
      <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-3 text-center">
        <div class="text-red-300 font-mono">p-2</div>
        <div class="text-2xl font-bold text-red-400 my-1">1</div>
        <div class="text-xs text-red-300">比前面的 2 小！</div>
      </div>
    </div>
  </div>
</div>

<!--
再來看情況二：順序改變，需要移動。

舊子節點還是 p-1、p-2、p-3，但新子節點變成 p-3、p-1、p-2，順序不一樣了。

[點擊] 同樣的方式，我們遍歷新子節點去找它們在舊列表的索引：
p-3 在索引 2
p-1 在索引 0，注意！0 比前面的 2 還小
p-2 在索引 1，同樣比 2 小

索引序列是 2、0、1，不是遞增的！

這就代表順序改變了。具體來說，p-1 和 p-2 的位置「相對於 p-3」往後跑了，所以它們需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-3xl text-gray-300 mb-8">
    核心規則
  </div>

  <div class="text-4xl text-yellow-300 leading-loose">
    如果在遍歷新子節點的過程中<br>
    發現某個節點在舊子節點中的索引<br>
    <span class="text-red-400 font-bold text-5xl">比前面的節點索引小</span><br>
    那麼這個節點就需要移動
  </div>
</div>

<!--
從剛剛的觀察，我們可以歸納出一個核心規則：

在遍歷新子節點的過程中，如果發現某個節點在舊子節點中的索引，比我們之前遇到的索引還要小，那這個節點就需要移動。

簡單說：索引應該要越來越大，如果突然變小了，就代表順序亂了，需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 mb-12">
    為了實現這個規則<br>
    我們需要一個變量
  </div>

  <div v-click class="text-8xl font-bold font-mono mb-12">
    <span class="text-purple-400">lastIndex</span>
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed">
    記錄當前遇到的<br>
    <span class="text-yellow-300 font-bold text-4xl">最大索引值</span>
  </div>
</div>

<!--
為了實現這個規則，我們需要用一個變數來記錄「目前遇到的最大索引值」。

[點擊] 這個變數就叫做 lastIndex。

[點擊] 它的作用是記錄我們在遍歷過程中遇到的最大索引值，用來跟後續的索引做比較。
-->

---

# lastIndex 的判斷邏輯

<div class="overflow-y-auto max-h-100 mt-6">

```js {all|1|5-6|10|13-15|16-20|all}{lines:true}
let lastIndex = 0 // 初始化為 0

for (let i = 0; i < newChildren.length; i++) {
  const newVNode = newChildren[i]
  // 遍歷舊的 children
  for (let j = 0; j < oldChildren.length; j++) {
    const oldVNode = oldChildren[j]

    if (newVNode.key === oldVNode.key) {
      // 找到可復用節點，j 是它在舊 children 中的索引

      // 🔑 關鍵判斷
      if (j < lastIndex) {
        // 當前索引 < 最大索引 → 需要移動
        console.log(`節點 ${newVNode.key} 需要移動`)
      }
      else {
        // 當前索引 >= 最大索引 → 不需要移動
        // 更新 lastIndex
        lastIndex = j
      }

      break
    }
  }
}
```

</div>

<!--
來看看 lastIndex 的判斷邏輯怎麼寫。

[點擊] 首先，lastIndex 初始化為 0。

[點擊] 然後我們用雙層迴圈，外層遍歷新 children，內層遍歷舊 children。

[點擊] 當我們找到可復用的節點時，j 就是它在舊 children 中的索引。

[點擊] 接下來是關鍵的判斷：

[點擊] 如果 j 小於 lastIndex，代表這個節點在舊列表中的位置比之前的還要前面，順序亂了，需要移動。

[點擊] 如果 j 大於等於 lastIndex，代表順序是對的，不需要移動。這時候我們把 lastIndex 更新成 j。

[點擊] 這樣 lastIndex 就會一直維持是「目前遇到的最大索引」。
-->

---

# 實現程式碼

<div class="overflow-y-auto max-h-100 mt-4">

```js {all|6|10-11|15-16|18-26|all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children

    let lastIndex = 0 // 記錄遇到的最大索引值

    for (let i = 0; i < newChildren.length; i++) {
      const newVNode = newChildren[i]
      // 遍歷舊的 children
      for (let j = 0; j < oldChildren.length; j++) {
        const oldVNode = oldChildren[j]

        if (newVNode.key === oldVNode.key) {
          // 先調用 patch 函數進行更新
          patch(oldVNode, newVNode, container)

          // 判斷是否需要移動
          if (j < lastIndex) {
            // 需要移動（具體如何移動下一節講解）
            console.log(`節點 ${newVNode.key} 需要移動`)
          }
          else {
            // 不需要移動，更新 lastIndex
            lastIndex = j
          }

          break
        }
      }
    }
  }
}
```

</div>

<!--
來看完整的實現程式碼。

[點擊] 在函數開頭初始化 lastIndex 為 0。

[點擊] 用雙層迴圈去找相同 key 的節點。

[點擊] 找到之後，先呼叫 patch 函數進行更新。這一步很重要！因為即使可以復用，內容可能還是有變化。

[點擊] 然後判斷是否需要移動：j 小於 lastIndex 就需要移動，否則更新 lastIndex。

[點擊] 這就是完整的簡單 Diff 判斷邏輯。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-yellow-300 font-bold">
    lastIndex 的作用
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed">
    • 始終存儲著<span class="text-blue-300 font-bold">當前遇到的最大索引值</span><br>
    • 用於判斷<span class="text-green-300 font-bold">後續節點是否需要移動</span><br>
    • 如果後續節點的索引 &lt; lastIndex<br>
    說明<span class="text-red-300 font-bold">順序改變了，需要移動</span>
  </div>
</div>

<!--
讓我們來總結一下 lastIndex 的作用：

[點擊] 
第一，它始終存儲著我們目前遇到的最大索引值。
第二，它用來判斷後續的節點是否需要移動。
第三，如果後續節點的索引比 lastIndex 小，就說明順序亂了，那個節點需要移動。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div v-click class="text-4xl text-gray-300">
    為什麼這個方法有效？
  </div>

  <div v-click class="text-3xl text-gray-300 leading-loose px-12">
    因為如果新舊子節點的<span class="text-blue-300 font-bold">順序相同</span><br>
    那麼在遍歷新子節點的過程中<br>
    找到的對應舊節點的索引應該是<span class="text-green-300 font-bold text-4xl">遞增的</span>
  </div>

  <div v-click class="text-3xl text-yellow-300 leading-loose px-12">
    如果索引不是遞增的<br>
    就說明<span class="text-red-300 font-bold">順序改變了，需要移動</span>
  </div>
</div>

<!--
你可能會問：為什麼這個方法有效？

[點擊] 讓我解釋一下背後的邏輯。

[點擊] 如果新舊子節點的順序相同，那麼當我們按順序遍歷新子節點，去舊列表中查找時，找到的索引應該是遞增的。就像剛剛情況一那樣：0、1、2。

[點擊] 但如果索引突然變小了，比 lastIndex 還小，就代表這個節點在舊列表中的位置比較前面，但在新列表中卻排在後面，順序變了，所以需要移動。
-->

---
layout: center
---

<div class="text-center">
  <div v-click class="text-4xl text-gray-300 mb-12">
    現在我們知道了<br>
    <span class="text-green-400 font-bold">如何判斷節點需要移動</span>
  </div>

  <div v-click class="text-5xl text-yellow-300 font-bold mb-12">
    但是...
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    具體要怎麼移動這些節點呢？<br>
    <span class="text-purple-400 font-bold">移動到哪裡？</span>
  </div>
</div>

<!--
好，到這裡我們已經知道怎麼判斷一個節點需不需要移動了。

[點擊] 我們用 lastIndex 來追蹤目前遇到的最大索引。

[點擊] 但是...還有一個問題。

[點擊] 我們知道它「需要移動」，但具體要怎麼移動？移動到哪個位置？這就是下一節要討論的內容。
-->
