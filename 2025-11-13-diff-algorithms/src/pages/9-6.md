---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-red-400 mb-12">
    移除不存在的元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    卸載在新子節點中<br>
    <span class="text-yellow-300 font-bold">不存在</span>的舊節點
  </div>
</div>

<!--
9.6 移除不存在的元素

[點擊] 卸載在新子節點中不存在的舊節點
-->

---

# 問題：遺留節點

<div class="mt--4 scale-75">
  <NodesMapping
    :rows="[
      { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
      { oldNode: 'p-2', index: 1 },
      { newNode: 'p-1', oldNode: 'p-3', index: 2, targetIndex: 0 },
      { oldNode: 'p-4', index: 3 },
    ]"
  />
</div>

<div v-click class="mt--4 bg-red-900/20 border border-red-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-red-300">
    <span class="text-red-400 font-bold">p-2</span> 和 <span class="text-red-400 font-bold">p-4</span> 在新子節點中<span class="font-bold">不存在</span>，需要被卸載
  </div>
</div>

<!--
問題：遺留節點

舊子節點有 p-1, p-2, p-3, p-4

新子節點只有 p-3, p-1

[點擊] p-2 和 p-4 在新子節點中不存在（紅色虛線框），需要被卸載
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-yellow-300 mb-12">
    為什麼會有遺留節點？
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed mb-8">
    現有邏輯是<span class="text-blue-300 font-bold">遍歷新子節點</span>
  </div>

  <div v-click class="text-2xl text-gray-400 leading-loose">
    如果某個舊節點不在新節點中<br>
    <span class="text-red-400 font-bold text-3xl">它永遠不會被處理！</span>
  </div>
</div>

<!--
為什麼會有遺留節點？

[點擊] 現有邏輯是遍歷新子節點

[點擊] 如果某個舊節點不在新節點中，它永遠不會被處理！
-->

---

# 現有邏輯的問題

<div class="mt-6">
  <div class="text-center text-sm text-gray-400 mb-4">遍歷新子節點，逐個處理</div>

  <div class="flex justify-center gap-8">
    <!-- 新子節點 -->
    <div class="space-y-3">
      <div class="text-center text-sm text-green-300 font-bold mb-2">新子節點</div>
      <div class="flex items-center gap-2">
        <div class="w-16 h-10 bg-green-600 rounded flex items-center justify-center text-white text-sm font-bold">p-3</div>
        <div class="text-green-400 text-xs">✓ 處理</div>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-16 h-10 bg-green-600 rounded flex items-center justify-center text-white text-sm font-bold">p-1</div>
        <div class="text-green-400 text-xs">✓ 處理</div>
      </div>
    </div>
    <!-- 箭頭 -->
    <div class="flex items-center text-3xl text-gray-500">→</div>
    <!-- 舊子節點 -->
    <div class="space-y-3">
      <div class="text-center text-sm text-blue-300 font-bold mb-2">舊子節點</div>
      <div class="w-16 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div v-click="1" class="w-16 h-10 border-2 border-dashed border-red-400 bg-red-900/20 rounded flex items-center justify-center text-red-300 text-sm">p-2</div>
      <div class="w-16 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div v-click="1" class="w-16 h-10 border-2 border-dashed border-red-400 bg-red-900/20 rounded flex items-center justify-center text-red-300 text-sm">p-4</div>
    </div>
    <!-- 說明 -->
    <div v-click="1" class="flex items-center">
      <div class="text-red-400 text-sm leading-relaxed">
        ← 從未被處理！<br>
        <span class="text-gray-500">DOM 仍存在</span>
      </div>
    </div>
  </div>
</div>

<div v-click="2" class="mt-6 bg-red-900/20 border border-red-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-red-300">
    只遍歷<span class="text-green-400 font-bold">新子節點</span>，無法處理<span class="text-red-400 font-bold">被刪除的舊節點</span>
  </div>
</div>

<!--
現有邏輯的問題：

遍歷新子節點，只處理 p-3 和 p-1

[點擊] p-2 和 p-4 從未被處理，顯示紅色虛線框

[點擊] 結論：只遍歷新子節點，無法處理被刪除的舊節點
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-green-300 mb-12">
    解決方案
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    遍歷舊子節點
  </div>

  <div v-click class="text-2xl text-gray-300">
    檢查每個舊節點是否在新子節點中存在<br>
    <span class="text-red-400 font-bold">不存在 → unmount</span>
  </div>
</div>

<!--
解決方案：

[點擊] 遍歷舊子節點

[點擊] 檢查每個舊節點是否在新子節點中存在，不存在就 unmount
-->

---

# 實現代碼

<div class="overflow-y-auto max-h-100 mt-4">

````md magic-move
```js {all}{lines:true}
// 基本更新完成後...

for (let i = 0; i < oldChildren.length; i++) {
  const oldVNode = oldChildren[i]

  // 檢查是否在新子節點中存在
  const has = newChildren.find(
    vnode => vnode.key === oldVNode.key
  )

  if (!has) {
    // 不存在 → 卸載
    unmount(oldVNode)
  }
}
```
```js {all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children
    let lastIndex = 0

    // 第一階段：遍歷新子節點
    for (let i = 0; i < newChildren.length; i++) {
      // ... 更新、移動、新增邏輯
    }

    // 第二階段：遍歷舊子節點，刪除遺留節點
    for (let i = 0; i < oldChildren.length; i++) {
      const oldVNode = oldChildren[i]
      const has = newChildren.find(
        vnode => vnode.key === oldVNode.key
      )
      if (!has) {
        unmount(oldVNode)
      }
    }
  }
}
```
````

</div>

<!--
實現代碼：

第一步：展示刪除遺留節點的核心邏輯

[點擊] 第二步：展示完整的 patchChildren 函數，包含兩個階段
-->

---
clicks: 16
---

# 完整案例演示

<div class="mt-8"></div>

<DiffAnimationUnmount :clicks="$clicks" />

<!--
完整案例演示

案例：[p-1, p-2, p-3, p-4] → [p-3, p-1]

請點擊或按空格鍵逐步查看動畫演示

（動畫共 16 步，展示更新和卸載的完整流程）
-->

---

# 兩階段更新邏輯

<div class="mt-8 grid grid-cols-2 gap-6">
  <div v-click="1" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">
    <div class="text-xl font-bold text-blue-300 mb-4 flex items-center">
      <div class="i-carbon-update-now mr-2"></div>
      第一階段
    </div>
    <div class="text-sm space-y-2">
      <div class="font-bold text-blue-200 mb-3">遍歷新子節點</div>
      <div>1. 查找可復用節點</div>
      <div>2. 執行 patch 更新</div>
      <div>3. 判斷是否需要移動</div>
      <div>4. 處理新增節點</div>
    </div>
  </div>

  <div v-click="2" class="bg-red-900/20 border border-red-500/30 rounded-lg p-5">
    <div class="text-xl font-bold text-red-300 mb-4 flex items-center">
      <div class="i-carbon-trash-can mr-2"></div>
      第二階段
    </div>
    <div class="text-sm space-y-2">
      <div class="font-bold text-red-200 mb-3">遍歷舊子節點</div>
      <div>1. 檢查是否在新子節點中</div>
      <div>2. 如果不存在，調用 unmount</div>
      <div>3. 清理遺留的 DOM 元素</div>
    </div>
  </div>
</div>

<div v-click="3" class="mt-6 bg-green-900/20 border border-green-500/30 rounded-lg p-4 text-center">
  <span class="text-green-300 font-bold">完整流程：</span>
  <span class="text-gray-300">更新 → 移動 → 新增 → 刪除</span>
</div>

<!--
兩階段更新邏輯：

[點擊] 第一階段：遍歷新子節點，執行更新、移動、新增

[點擊] 第二階段：遍歷舊子節點，刪除遺留節點

[點擊] 完整流程：更新 → 移動 → 新增 → 刪除，四種操作協同完成
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• 遺留節點：舊節點不在新 children 中</div>
    <div v-click="2">• 解決：遍歷舊子節點 + <code class="text-red-300">unmount</code></div>
    <div v-click="3">• 用 <code class="text-yellow-300">find</code> 檢查是否存在</div>
    <div v-click="4">• 兩階段：<span class="text-blue-300">新→舊</span>，<span class="text-red-300">舊→刪</span></div>
  </div>
</div>

<!--
9.6 小結：

[點擊] 遺留節點：舊節點不在新 children 中

[點擊] 解決方案：遍歷舊子節點 + unmount

[點擊] 用 find 檢查是否存在

[點擊] 兩階段：先遍歷新子節點，再遍歷舊子節點刪除
-->

---
layout: center
---

<div class="text-center space-y-8">
  <div class="text-5xl text-green-400 font-bold mb-8">
    簡單 Diff 演算法總結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-3 text-left inline-block">
    <div v-click="1">1. <span class="text-blue-300 font-bold">key 的作用</span>：唯一標識節點，實現 DOM 復用</div>
    <div v-click="2">2. <span class="text-purple-300 font-bold">找到需要移動的元素</span>：使用 lastIndex 判斷</div>
    <div v-click="3">3. <span class="text-yellow-300 font-bold">如何移動元素</span>：insertBefore + 錨點</div>
    <div v-click="4">4. <span class="text-green-300 font-bold">添加新元素</span>：find 標誌 + 掛載到正確位置</div>
    <div v-click="5">5. <span class="text-red-300 font-bold">移除不存在的元素</span>：遍歷舊節點 + unmount</div>
  </div>
</div>

<!--
簡單 Diff 演算法總結：

[點擊] key 的作用：唯一標識節點，實現 DOM 復用

[點擊] 找到需要移動的元素：使用 lastIndex 判斷

[點擊] 如何移動元素：insertBefore + 錨點

[點擊] 添加新元素：find 標誌 + 掛載到正確位置

[點擊] 移除不存在的元素：遍歷舊節點 + unmount
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-yellow-300 font-bold">
    核心思想
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    通過 <span class="text-blue-300 font-bold">key</span> 找到可復用的節點<br>
    用<span class="text-green-400 font-bold">最少的 DOM 操作</span>完成更新
  </div>

  <div v-click class="text-3xl text-purple-300">
    接下來：雙端 Diff 演算法
  </div>
</div>

<!--
核心思想：

[點擊] 通過 key 找到可復用的節點，用最少的 DOM 操作完成更新

[點擊] 接下來我們將學習更高效的雙端 Diff 演算法
-->
