---
layout: center
---

<div class="text-center">
  <div class="text-5xl font-bold text-red-400 mb-12">
    移除不存在的元素
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    卸載在新子節點中<br>
    <span class="text-yellow-300 font-bold">不存在</span>的舊節點
  </div>
</div>

<!--
這一節我們來看最後一個問題：移除不存在的元素。

[點擊] 簡單來說，就是要卸載那些在新的子節點列表中已經不存在的舊節點。

什麼意思呢？讓我們看個例子。
-->

---

# 問題：遺留節點

<div class="mt--4 scale-75">
  <NodesMapping
    :rows="[
      { newNode: 'p-3', oldNode: 'p-1', index: 0, targetIndex: 2 },
      { oldNode: 'p-2', index: 1 },
      { newNode: 'p-1', oldNode: 'p-3', index: 2, targetIndex: 0 },
      { oldNode: 'p-4', index: 3 },
    ]"
  />
</div>

<div v-click class="mt--4 bg-red-900/20 border border-red-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-red-300">
    <span class="text-red-400 font-bold">p-2</span> 和 <span class="text-red-400 font-bold">p-4</span> 在新子節點中<span class="font-bold">不存在</span>，需要被卸載
  </div>
</div>

<!--
來看這個例子。

舊的子節點有四個：p-1、p-2、p-3、p-4。
但新的子節點只剩兩個：p-3 和 p-1。

[點擊] 你會發現 p-2 和 p-4 在新的列表中根本不存在了。這兩個節點如果還留在 DOM 裡面，那就是多餘的，必須要被卸載掉。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-yellow-300 mb-12">
    為什麼會有遺留節點？
  </div>

  <div v-click class="text-3xl text-gray-300 leading-relaxed mb-8">
    現有邏輯是<span class="text-blue-300 font-bold">遍歷新子節點</span>
  </div>

  <div v-click class="text-2xl text-gray-400 leading-loose">
    如果某個舊節點不在新節點中<br>
    <span class="text-red-400 font-bold text-3xl">它永遠不會被處理！</span>
  </div>
</div>

<!--
那為什麼會有這種遺留節點的問題呢？

[點擊] 原因是我們之前的邏輯是「遍歷新的子節點」。

[點擊] 想想看，如果某個舊節點根本不在新的列表裡，那它永遠不會被我們的迴圈碰到啊！所以它就這樣被遺漏了，一直留在 DOM 裡面。
-->

---

# 現有邏輯的問題

<div class="mt-6">
  <div class="text-center text-sm text-gray-400 mb-4">遍歷新子節點，逐個處理</div>

  <div class="flex justify-center gap-8">
    <!-- 新子節點 -->
    <div class="space-y-3">
      <div class="text-center text-sm text-green-300 font-bold mb-2">新子節點</div>
      <div class="flex items-center gap-2">
        <div class="w-16 h-10 bg-green-600 rounded flex items-center justify-center text-white text-sm font-bold">p-3</div>
        <div class="text-green-400 text-xs">✓ 處理</div>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-16 h-10 bg-green-600 rounded flex items-center justify-center text-white text-sm font-bold">p-1</div>
        <div class="text-green-400 text-xs">✓ 處理</div>
      </div>
    </div>
    <!-- 箭頭 -->
    <div class="flex items-center text-3xl text-gray-500">→</div>
    <!-- 舊子節點 -->
    <div class="space-y-3">
      <div class="text-center text-sm text-blue-300 font-bold mb-2">舊子節點</div>
      <div class="w-16 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-1</div>
      <div v-click="1" class="w-16 h-10 border-2 border-dashed border-red-400 bg-red-900/20 rounded flex items-center justify-center text-red-300 text-sm">p-2</div>
      <div class="w-16 h-10 bg-gray-700 rounded flex items-center justify-center text-white text-sm">p-3</div>
      <div v-click="1" class="w-16 h-10 border-2 border-dashed border-red-400 bg-red-900/20 rounded flex items-center justify-center text-red-300 text-sm">p-4</div>
    </div>
    <!-- 說明 -->
    <div v-click="1" class="flex items-center">
      <div class="text-red-400 text-sm leading-relaxed">
        ← 從未被處理！<br>
        <span class="text-gray-500">DOM 仍存在</span>
      </div>
    </div>
  </div>
</div>

<div v-click="2" class="mt-6 bg-red-900/20 border border-red-500/30 rounded-lg p-4 text-center">
  <div class="text-lg text-red-300">
    只遍歷<span class="text-green-400 font-bold">新子節點</span>，無法處理<span class="text-red-400 font-bold">被刪除的舊節點</span>
  </div>
</div>

<!--
讓我用圖解說明一下這個問題。

我們遍歷新的子節點，所以只會處理到 p-3 和 p-1，它們都打勾了。

[點擊] 但是看看右邊的舊子節點，p-2 和 p-4 從頭到尾都沒有被處理到。它們就這樣靜靜地留在 DOM 裡面。

[點擊] 所以結論很清楚：只遍歷新子節點，是沒辦法處理那些「被刪除」的舊節點的。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-green-300 mb-12">
    解決方案
  </div>

  <div v-click class="text-4xl text-yellow-300 font-bold leading-relaxed mb-8">
    遍歷舊子節點
  </div>

  <div v-click class="text-2xl text-gray-300">
    檢查每個舊節點是否在新子節點中存在<br>
    <span class="text-red-400 font-bold">不存在 → unmount</span>
  </div>
</div>

<!--
那解決方案是什麼呢？

[點擊] 很簡單，我們再加一個迴圈：遍歷舊的子節點。

[點擊] 對於每一個舊節點，我們去檢查它是不是還存在於新的子節點列表中。如果找不到，那就代表這個節點要被刪掉了，我們就呼叫 unmount 把它卸載。
-->

---

# 實現程式碼

<div class="overflow-y-auto max-h-100 mt-4">

````md magic-move
```js {all}{lines:true}
// 基本更新完成後...

for (let i = 0; i < oldChildren.length; i++) {
  const oldVNode = oldChildren[i]

  // 檢查是否在新子節點中存在
  const has = newChildren.find(
    vnode => vnode.key === oldVNode.key
  )

  if (!has) {
    // 不存在 → 卸載
    unmount(oldVNode)
  }
}
```
```js {all}{lines:true}
function patchChildren(n1, n2, container) {
  if (Array.isArray(n2.children)) {
    const oldChildren = n1.children
    const newChildren = n2.children
    let lastIndex = 0

    // 第一階段：遍歷新子節點
    for (let i = 0; i < newChildren.length; i++) {
      // ... 更新、移動、新增邏輯
    }

    // 第二階段：遍歷舊子節點，刪除遺留節點
    for (let i = 0; i < oldChildren.length; i++) {
      const oldVNode = oldChildren[i]
      const has = newChildren.find(
        vnode => vnode.key === oldVNode.key
      )
      if (!has) {
        unmount(oldVNode)
      }
    }
  }
}
```
````

</div>

<!--
來看一下程式碼怎麼寫。

這段程式碼非常直觀：我們遍歷所有舊的子節點，然後用 find 去新子節點裡面找有沒有相同 key 的節點。如果找不到，就呼叫 unmount 把它移除。

[點擊] 把這段邏輯放到完整的 patchChildren 函數裡，你可以看到整個更新流程分成兩個階段：

第一階段是遍歷新子節點，處理更新、移動、新增。
第二階段就是我們剛剛講的，遍歷舊子節點，刪除那些不存在的。
-->

---
clicks: 16
---

# 完整案例演示

<div class="mt-8"></div>

<DiffAnimationUnmount :clicks="$clicks" />

<!--
現在讓我們用一個完整的案例來演示整個流程。

舊的子節點是 p-1、p-2、p-3、p-4。
新的子節點是 p-3、p-1。

這個動畫會展示：
- 第一階段怎麼處理 p-3 和 p-1（更新和移動）
- 第二階段怎麼把 p-2 和 p-4 卸載掉

大家可以按空格鍵或點擊來一步步看這個過程，總共有 16 個步驟。
-->

---

# 兩階段更新邏輯

<div class="mt-8 grid grid-cols-2 gap-6">
  <div v-click="1" class="bg-blue-900/20 border border-blue-500/30 rounded-lg p-5">
    <div class="text-xl font-bold text-blue-300 mb-4 flex items-center">
      <div class="i-carbon-update-now mr-2"></div>
      第一階段
    </div>
    <div class="text-sm space-y-2">
      <div class="font-bold text-blue-200 mb-3">遍歷新子節點</div>
      <div>1. 查找可復用節點</div>
      <div>2. 執行 patch 更新</div>
      <div>3. 判斷是否需要移動</div>
      <div>4. 處理新增節點</div>
    </div>
  </div>

  <div v-click="2" class="bg-red-900/20 border border-red-500/30 rounded-lg p-5">
    <div class="text-xl font-bold text-red-300 mb-4 flex items-center">
      <div class="i-carbon-trash-can mr-2"></div>
      第二階段
    </div>
    <div class="text-sm space-y-2">
      <div class="font-bold text-red-200 mb-3">遍歷舊子節點</div>
      <div>1. 檢查是否在新子節點中</div>
      <div>2. 如果不存在，調用 unmount</div>
      <div>3. 清理遺留的 DOM 元素</div>
    </div>
  </div>
</div>

<div v-click="3" class="mt-6 bg-green-900/20 border border-green-500/30 rounded-lg p-4 text-center">
  <span class="text-green-300 font-bold">完整流程：</span>
  <span class="text-gray-300">更新 → 移動 → 新增 → 刪除</span>
</div>

<!--
好，讓我們整理一下這個兩階段的更新邏輯。

[點擊] 第一階段：我們遍歷新的子節點。在這個階段，我們會查找可以復用的節點、執行 patch 更新內容、判斷要不要移動位置、還有處理新增的節點。

[點擊] 第二階段：我們遍歷舊的子節點。這個階段比較單純，就是檢查每個舊節點還在不在新的列表裡，不在的話就呼叫 unmount 把它從 DOM 移除。

[點擊] 所以完整的 Diff 流程就是這四種操作：更新、移動、新增、刪除。順序是先處理新的，再清理舊的。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-green-400 font-bold">
    小結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-4">
    <div v-click="1">• 遺留節點：舊節點不在新 children 中</div>
    <div v-click="2">• 解決：遍歷舊子節點 + <code class="text-red-300">unmount</code></div>
    <div v-click="3">• 用 <code class="text-yellow-300">find</code> 檢查是否存在</div>
    <div v-click="4">• 兩階段：<span class="text-blue-300">新→舊</span>，<span class="text-red-300">舊→刪</span></div>
  </div>
</div>

<!--
來做個小結。

[點擊] 遺留節點是什麼？就是那些在舊的列表裡有、但在新的列表裡已經不見的節點。

[點擊] 怎麼解決？很簡單，再跑一個迴圈遍歷舊節點，找到要刪的就 unmount。

[點擊] 怎麼判斷要不要刪？用 find 方法去新的列表裡找，找不到就是要刪。

[點擊] 記住這個兩階段的概念：第一階段遍歷新的，處理更新移動新增；第二階段遍歷舊的，處理刪除。
-->

---
layout: center
---

<div class="text-center space-y-8">
  <div class="text-5xl text-green-400 font-bold mb-8">
    簡單 Diff 演算法總結
  </div>

  <div class="text-2xl text-gray-300 leading-loose space-y-3 text-left inline-block">
    <div v-click="1">1. <span class="text-blue-300 font-bold">key 的作用</span>：唯一標識節點，實現 DOM 復用</div>
    <div v-click="2">2. <span class="text-purple-300 font-bold">找到需要移動的元素</span>：使用 lastIndex 判斷</div>
    <div v-click="3">3. <span class="text-yellow-300 font-bold">如何移動元素</span>：insertBefore + 錨點</div>
    <div v-click="4">4. <span class="text-green-300 font-bold">添加新元素</span>：find 標誌 + 掛載到正確位置</div>
    <div v-click="5">5. <span class="text-red-300 font-bold">移除不存在的元素</span>：遍歷舊節點 + unmount</div>
  </div>
</div>

<!--
好，現在讓我們來總結整個簡單 Diff 演算法。這一章我們學了五個重點：

[點擊] 第一，key 的作用。key 就是節點的身分證，讓我們能夠識別「這個節點跟那個節點是同一個」，這樣才能復用 DOM 而不是重新建立。

[點擊] 第二，怎麼找到需要移動的元素。我們用 lastIndex 這個變數，如果當前節點在舊列表的索引比 lastIndex 小，就代表它需要移動。

[點擊] 第三，怎麼移動元素。用 insertBefore 這個 DOM API，配合正確的錨點位置來插入。

[點擊] 第四，怎麼添加新元素。用 find 這個 flag 來判斷是不是新節點，如果是就掛載到前一個節點的後面。

[點擊] 第五，就是我們這節講的，怎麼移除不存在的元素。遍歷舊節點，找不到的就 unmount。
-->

---
layout: center
---

<div class="text-center space-y-12">
  <div class="text-4xl text-yellow-300 font-bold">
    核心思想
  </div>

  <div v-click class="text-4xl text-gray-300 leading-relaxed">
    通過 <span class="text-blue-300 font-bold">key</span> 找到可復用的節點<br>
    用<span class="text-green-400 font-bold">最少的 DOM 操作</span>完成更新
  </div>

  <div v-click class="text-3xl text-purple-300">
    接下來：雙端 Diff 演算法
  </div>
</div>

<!--
最後，整個簡單 Diff 演算法的核心思想是什麼？

[點擊] 就是透過 key 找到可以復用的節點，然後想辦法用最少的 DOM 操作來完成更新。因為 DOM 操作是很貴的，我們要盡量避免不必要的建立和刪除。

[點擊] 不過，簡單 Diff 演算法還有優化的空間。接下來我們會學習雙端 Diff 演算法，它可以處理更多的邊界情況，效率也更好。
-->
