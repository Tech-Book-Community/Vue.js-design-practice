---
layout: center
---

# 還記得第一章的公式嗎？

<div v-click mt-8>

<div text-center text-2xl leading-relaxed>
<span text-yellow-300 font-bold>聲明式的更新性能消耗</span>
<span mx-3>=</span>
<span text-red-300 font-bold>找出差異的性能消耗</span>
<span mx-3>+</span>
<span text-green-300 font-bold>直接修改的性能消耗</span>
</div>

</div>

<!--
在開始講 Diff 演算法之前，我想先帶大家回顧一下第一章提到的這個核心公式。

[點擊] 聲明式的更新性能消耗，等於「找出差異的性能消耗」加上「直接修改的性能消耗」。

這個公式很重要，因為它是理解 Diff 演算法存在意義的關鍵。
-->

---
layout: center
---

# 聲明式永遠無法超越命令式？

<div v-click mt-8 text-xl text-gray-300>
聲明式程式碼的效能理論上不可能超越命令式程式碼<br>
因為它多了「找出差異」這一步
</div>

<div v-click mt-8>

<div class="px-8 py-6 bg-blue-900/20 border-2 border-blue-500/40 rounded-lg inline-block">
<div text-2xl text-blue-300>
但是，如果我們能夠 <span text-yellow-300 font-bold>最小化找出差異的效能消耗</span>
</div>
<div text-2xl text-blue-300 mt-2>
就可以讓聲明式程式碼的效能 <span text-green-300 font-bold>無限接近</span> 命令式程式碼
</div>
</div>

</div>

<!--
當時我們說，聲明式程式碼的效能理論上不可能超越命令式程式碼，為什麼？因為它多了「找出差異」這一步嘛。

[點擊] 但是！這不代表我們就放棄了。虛擬 DOM 的核心目標，就是要盡可能最小化這個「找出差異」的成本。

如果我們能把找出差異的效能消耗壓得夠低，聲明式程式碼的效能就可以無限接近命令式程式碼。這就是我們追求的目標。
-->

---
layout: center
---

<div flex items-center justify-center gap-12>
  <div i-carbon-compare text-8xl text-purple-400 />
  <div>
    <h1>Diff 演算法</h1>
    <div text-2xl text-gray-300 mt-4>尋找差異的演算法</div>
  </div>
</div>

<div v-click mt-12 text-center text-xl text-yellow-300>
它直接決定了 Vue 的效能上限
</div>

<!--
而這個「尋找差異」的演算法，就叫做 Diff 演算法。

[點擊] 所以你可以理解為什麼 Diff 演算法這麼重要了吧？它直接決定了 Vue 的效能上限。Diff 演算法越聰明，Vue 就越快。
-->

---
layout: center
---

# Diff 演算法要解決什麼問題？

<div v-click mt-8 text-xl text-gray-300>
在渲染器中，當新舊虛擬節點的子節點都是一組節點時<br>
我們需要對比這兩組子節點，找出它們的差異並更新
</div>

<!--
那 Diff 演算法具體要解決什麼問題呢？

[點擊] 簡單來說，在渲染器中，當新舊虛擬節點的子節點都是「一組節點」的時候，我們就需要對比這兩組子節點，找出它們之間的差異，然後做最小化的更新。

什麼叫「一組節點」？就是子節點是陣列的情況，比如一個列表有很多項目。
-->

---

# 舉個例子

<div grid grid-cols-2 gap-12 mt-8>
  <div v-click="1">
    <div text-xl font-bold mb-4 text-blue-300>
      舊的虛擬節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{
  type: 'div',
  children: [
    { type: 'p', children: '1' },
    { type: 'p', children: '2' },
    { type: 'p', children: '3' }
  ]
}
```
    </div>
  </div>

  <div v-click="2">
    <div text-xl font-bold mb-4 text-green-300>
      新的虛擬節點
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
```js
{
  type: 'div',
  children: [
    { type: 'p', children: '4' },
    { type: 'p', children: '5' },
    { type: 'p', children: '6' }
  ]
}
```
    </div>
  </div>
</div>

<!--
讓我們來看一個具體的例子。

[點擊] 假設我們有一個舊的虛擬節點，它有三個 p 標籤作為子節點，內容分別是 1、2、3。

[點擊] 然後狀態更新了，新的虛擬節點也是三個 p 標籤，但內容變成了 4、5、6。

現在問題來了：我們要怎麼把畫面從舊的更新成新的？
-->

---

# 回顧第 8 章：最簡單但最慢的做法

<div v-click="1" mt-8>

**卸載所有舊子節點 → 掛載所有新子節點**

<div class="bg-gray-800/50 rounded-lg p-4 mt-4">

```js
function patchChildren(n1, n2, container) {
  // 卸載所有舊子節點
  if (Array.isArray(n1.children)) {
    n1.children.forEach(c => unmount(c))
  }

  // 掛載所有新子節點
  if (Array.isArray(n2.children)) {
    n2.children.forEach(c => patch(null, c, container))
  }
}
```

</div>

</div>

<!--
[點擊] 回顧一下第 8 章，當時我們處理子節點更新的方式非常暴力：直接把所有舊的子節點全部卸載，然後把所有新的子節點全部掛載上去。

簡單粗暴，但這樣真的好嗎？
-->

---
layout: center
---

# 但這真的是最好的方案嗎？ 🤔

---
layout: center
---

# 仔細觀察

<div v-click text-4xl text-center leading-relaxed mt-12>
標籤類型都是 <code class="bg-blue-500/20 px-4 py-2 rounded text-blue-300 text-5xl">p</code>
</div>

<div v-click text-4xl text-center mt-8>
只有 <span text-green-400 font-bold>文字內容</span> 不同
</div>

<!--
等一下，讓我們仔細觀察一下這個例子，看看有沒有什麼發現。

[點擊] 你看，新舊兩組子節點的標籤類型都是 p，完全一樣！

[點擊] 唯一不同的只是裡面的文字內容而已。

既然標籤都一樣，我們能不能直接復用這些 DOM 元素，只更新裡面的文字就好？
-->

---

# 這個做法的問題是什麼？

<div v-click="1" mt-8>

<div class="px-8 py-6 bg-red-900/20 border-2 border-red-500/40 rounded-lg inline-block">
<div text-3xl text-red-300 font-bold>
❌ 沒有復用任何 DOM 元素！
</div>
</div>

</div>

<div v-click="2" mt-8 text-xl>

對於上面的例子：
- 卸載 3 個 `<p>` 標籤 = **3 次 DOM 刪除操作**
- 掛載 3 個 `<p>` 標籤 = **3 次 DOM 添加操作**
- <span text-red-400 font-bold text-2xl>總共：6 次 DOM 操作</span>

</div>

<!--
這個做法有什麼問題呢？

[點擊] 最大的問題就是：完全沒有復用任何 DOM 元素！

[點擊] 你想想看，把舊的三個節點全部刪掉需要 3 次 DOM 刪除操作，再把新的三個節點全部加上去又需要 3 次 DOM 添加操作，總共 6 次 DOM 操作。

而 DOM 操作是很昂貴的，我們應該盡量避免。
-->

---

# 方案對比

<div grid grid-cols-2 gap-8 mt-8>
  <div class="p-8 bg-red-900/10 rounded-xl">
    <div text-2xl font-bold mb-6 text-red-300 flex items-center>
      <div i-carbon-close mr-3 text-3xl />暴力方案
    </div>
    <div space-y-3 text-lg text-gray-300>
      <div>卸載 3 個舊節點</div>
      <div>掛載 3 個新節點</div>
    </div>
    <div class="mt-6 pt-6 border-t-2 border-red-500/30">
      <div font-bold text-4xl text-center text-red-300>6 次操作</div>
    </div>
  </div>

  <div v-click class="p-8 bg-green-900/10 rounded-xl">
    <div text-2xl font-bold mb-6 text-green-300 flex items-center>
      <div i-carbon-checkmark mr-3 text-3xl />復用方案
    </div>
    <div space-y-3 text-lg text-gray-300>
      <div>復用 3 個 DOM 元素</div>
      <div>更新 3 次文字內容</div>
    </div>
    <div class="mt-6 pt-6 border-t-2 border-green-500/30">
      <div font-bold text-4xl text-center text-green-300>3 次操作</div>
    </div>
  </div>
</div>

<!--
讓我們來對比一下這兩種方案。

左邊是暴力方案，需要 6 次 DOM 操作：刪掉 3 個舊節點，再加上 3 個新節點。

[點擊] 右邊是復用方案，只需要 3 次操作：直接復用現有的 3 個 DOM 元素，只更新裡面的文字內容。

差了一倍！這就是為什麼我們要想辦法復用 DOM。
-->

---
layout: center
---

<div text-center>

# 這就是 Diff 演算法要做的事情

<div v-click mt-8 text-2xl text-green-300>
找出可以復用的節點<br>
用最少的 DOM 操作完成更新
</div>

</div>

<!--
所以這就是 Diff 演算法的核心任務：找出哪些節點可以復用，然後用最少的 DOM 操作來完成更新。

聽起來很簡單對吧？但實際上還有很多細節要處理。
-->

---

# 但問題來了... 🤔

<div mt-12 text-2xl text-gray-300 leading-relaxed>

<div v-click>❓ 我們要怎麼知道哪些節點可以復用？</div>
<div v-click mt-4>❓ 哪些需要移動？</div>
<div v-click mt-4>❓ 哪些需要新增或刪除？</div>

</div>

<div v-click mt-12 flex items-center justify-center>
  <div class="px-12 py-8 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
    <div text-3xl text-purple-300>
      這就需要一個聰明的演算法 💡
    </div>
  </div>
</div>

<!--
但問題來了，實際情況沒那麼單純：

[點擊] 我們要怎麼知道哪些節點可以復用？
[點擊] 如果順序變了，哪些節點需要移動？
[點擊] 如果數量變了，哪些需要新增？哪些需要刪除？

[點擊] 這些問題都需要一個聰明的演算法來解決，這就是 Diff 演算法的價值所在。
-->

---

# Diff 演算法的核心任務

<div grid grid-cols-3 gap-8 mt-12>
  <div v-click="1" class="border-2 border-purple-500/30 rounded-lg p-8 bg-purple-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-compare text-5xl text-purple-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-purple-300>比較差異</div>
      <div text-lg text-gray-300>對比新舊虛擬節點</div>
    </div>
  </div>

  <div v-click="2" class="border-2 border-blue-500/30 rounded-lg p-8 bg-blue-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-renew text-5xl text-blue-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-blue-300>找出復用</div>
      <div text-lg text-gray-300>標記可復用的節點</div>
    </div>
  </div>

  <div v-click="3" class="border-2 border-green-500/30 rounded-lg p-8 bg-green-900/20">
    <div flex items-center justify-center mb-4>
      <div i-carbon-chip text-5xl text-green-300 />
    </div>
    <div text-center>
      <div font-bold text-2xl mb-3 text-green-300>計算操作</div>
      <div text-lg text-gray-300>移動、新增、刪除</div>
    </div>
  </div>
</div>

<div v-click="4" mt-12 text-center>
  <div class="px-12 py-6 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg inline-block">
    <div text-2xl text-yellow-300>
      🎯 以最小的性能開銷完成更新操作
    </div>
  </div>
</div>

<!--
具體來說，Diff 演算法有三大核心任務：

[點擊] 第一，比較差異。把新舊兩組虛擬節點拿來對比。

[點擊] 第二，找出復用。判斷哪些節點是可以復用的，不需要重新建立。

[點擊] 第三，計算操作。決定要執行哪些 DOM 操作：移動、新增、還是刪除。

[點擊] 最終目標就是用最小的性能開銷來完成整個更新。
-->

---

# 本次分享的範圍

<div mt-12 text-2xl text-gray-300>
今天我們會介紹兩種<span text-yellow-300 font-bold>基礎但重要</span>的演算法
</div>

<div grid grid-cols-2 gap-8 mt-12>
  <div v-click="1" class="border-2 border-blue-500/30 rounded-lg p-8 bg-blue-900/20">
    <div text-2xl font-bold mb-6 text-blue-300>
      📖 第 9 章：簡單 Diff 演算法
    </div>
    <div text-lg space-y-3 text-gray-300>
      <div>• 核心概念：<code class="bg-blue-800/30 px-2 py-1 rounded">lastIndex</code> 與單向掃描</div>
      <div>• 理解如何判斷節點需要移動</div>
      <div>• 理解 <code class="bg-blue-800/30 px-2 py-1 rounded">key</code> 的作用</div>
    </div>
  </div>

  <div v-click="2" class="border-2 border-green-500/30 rounded-lg p-8 bg-green-900/20">
    <div text-2xl font-bold mb-6 text-green-300>
      📖 第 10 章：雙端 Diff 演算法
    </div>
    <div text-lg space-y-3 text-gray-300>
      <div>• 核心概念：從兩端向中間掃描</div>
      <div>• 理解如何減少移動次數</div>
      <div>• Vue 2 使用的演算法</div>
    </div>
  </div>
</div>

<!--
今天我們會介紹兩種基礎但非常重要的演算法：

[點擊] 第 9 章是簡單 Diff 演算法。核心概念是 lastIndex 和單向掃描。我們會學習怎麼判斷一個節點需不需要移動，還有 key 這個屬性到底有什麼用。

[點擊] 第 10 章是雙端 Diff 演算法。核心概念是從兩端同時往中間掃描。這個演算法可以減少移動次數，也是 Vue 2 實際使用的演算法。
-->

---
layout: intro
class: text-center
---

<div>
  <div text-6xl font-bold text-blue-400>準備好了嗎？</div>
  <div v-click mt-8 text-3xl text-gray-300>讓我們從最基礎的</div>
  <div v-click mt-4 text-5xl font-bold text-green-400>簡單 Diff 演算法</div>
  <div v-click mt-4 text-3xl text-gray-300>開始！🚀</div>
</div>

<!--
好，大家準備好了嗎？

[點擊] 接下來，讓我們從最基礎的
[點擊] 簡單 Diff 演算法
[點擊] 開始吧！
-->
