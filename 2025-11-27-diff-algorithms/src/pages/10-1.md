---
layout: center
---

# 第 10 章：雙端 Diff 算法

<div class="mt-8 text-2xl text-gray-400">
從簡單 Diff 到更優的解決方案
</div>

<!--
好，進入第 10 章，我們來學雙端 Diff 算法。

上一章學的簡單 Diff 算法，利用 key 屬性來複用 DOM，用 lastIndex 判斷是否需要移動節點。

但簡單 Diff 有一個問題：它的移動次數不是最優的。這一章我們來看雙端 Diff 如何解決這個問題。
-->

---
clicks: 15
---

# 簡單 Diff 的問題

<DiffAnimationMove :clicks="$clicks" />

<div v-click="15" class="mt-8 text-center">
  <span class="text-3xl text-red-400 font-bold">結果：2 次移動</span>
</div>

<!--
先來看一個例子，理解簡單 Diff 的問題在哪。

舊子節點是 p-1、p-2、p-3，新子節點是 p-3、p-1、p-2。

用簡單 Diff 算法來處理，請點擊或按空格鍵逐步查看動畫。

處理完之後會發現，簡單 Diff 需要移動 2 次。
-->

---
layout: center
---

<div class="text-center">
  <div class="text-4xl text-gray-300 mb-8">但其實...</div>
  <div v-click class="text-3xl text-green-400 leading-relaxed">
    只要把 <span class="text-yellow-300 font-bold">p-3 移到最前面</span><br>
    <span class="text-5xl font-bold mt-4 inline-block">1 次移動就夠了！</span>
  </div>
</div>

<!--
但其實仔細想想...

[點擊] 只要把 p-3 移到最前面，1 次移動就夠了！

這就是簡單 Diff 的問題：它沒辦法找到最優的移動方案。那有沒有更好的方法？有，就是雙端 Diff。
-->

---

# 雙端 Diff 的核心思想

<div class="mt-8 text-2xl text-gray-300 mb-8">
同時從<span class="text-cyan-400 font-bold">兩端</span>進行比較，用四個索引：
</div>

<div class="grid grid-cols-2 gap-8">
  <div class="bg-green-900/20 border-2 border-green-500/40 rounded-lg p-6">
    <div class="text-xl font-bold mb-4 text-green-300">新子節點</div>
    <div class="flex justify-between items-center text-2xl font-mono">
      <span class="text-cyan-400">p-3</span>
      <span>p-1</span>
      <span class="text-orange-400">p-2</span>
    </div>
    <div class="flex justify-between mt-2 text-sm">
      <span class="text-cyan-400">↑ newStartIdx</span>
      <span class="text-orange-400">newEndIdx ↑</span>
    </div>
  </div>

  <div class="bg-blue-900/20 border-2 border-blue-500/40 rounded-lg p-6">
    <div class="text-xl font-bold mb-4 text-blue-300">舊子節點</div>
    <div class="flex justify-between items-center text-2xl font-mono">
      <span class="text-cyan-400">p-1</span>
      <span>p-2</span>
      <span class="text-orange-400">p-3</span>
    </div>
    <div class="flex justify-between mt-2 text-sm">
      <span class="text-cyan-400">↑ oldStartIdx</span>
      <span class="text-orange-400">oldEndIdx ↑</span>
    </div>
  </div>
</div>

<div v-click class="mt-8 text-center text-xl text-yellow-300">
四個索引指向新舊兩組子節點的<span class="font-bold">頭部</span>和<span class="font-bold">尾部</span>
</div>

<!--
雙端 Diff 的核心思想是什麼？就是同時從兩端進行比較，用四個索引來追蹤。

左邊是新子節點，右邊是舊子節點。
newStartIdx 和 oldStartIdx 指向頭部，用青色標示。
newEndIdx 和 oldEndIdx 指向尾部，用橙色標示。

[點擊] 這四個索引分別指向新舊兩組子節點的頭部和尾部。每一輪比較會用這四個指標來配對。
-->

---

# 四步比較

<div class="mt-8 text-xl text-gray-300 mb-6">
每一輪比較分四步，命中任一步就處理，然後進入下一輪：
</div>

<div class="grid grid-cols-2 gap-6">
  <div v-click class="p-4 bg-cyan-900/20 border-2 border-cyan-500/40 rounded-lg">
    <div class="text-lg font-bold text-cyan-300 mb-2">① 頭頭比較</div>
    <div class="text-gray-300">newStart vs oldStart</div>
  </div>

  <div v-click class="p-4 bg-orange-900/20 border-2 border-orange-500/40 rounded-lg">
    <div class="text-lg font-bold text-orange-300 mb-2">② 尾尾比較</div>
    <div class="text-gray-300">newEnd vs oldEnd</div>
  </div>

  <div v-click class="p-4 bg-purple-900/20 border-2 border-purple-500/40 rounded-lg">
    <div class="text-lg font-bold text-purple-300 mb-2">③ 交叉比較（新尾 vs 舊頭）</div>
    <div class="text-gray-300">newEnd vs oldStart</div>
  </div>

  <div v-click class="p-4 bg-pink-900/20 border-2 border-pink-500/40 rounded-lg">
    <div class="text-lg font-bold text-pink-300 mb-2">④ 交叉比較（新頭 vs 舊尾）</div>
    <div class="text-gray-300">newStart vs oldEnd</div>
  </div>
</div>

<div v-click class="mt-8 text-center text-xl text-green-400">
命中後執行對應操作，移動索引，進入下一輪
</div>

<!--
每一輪比較分四步，依序嘗試：

[點擊] 第一步：頭頭比較，比 newStart 和 oldStart

[點擊] 第二步：尾尾比較，比 newEnd 和 oldEnd

[點擊] 第三步：交叉比較，比 newEnd 和 oldStart

[點擊] 第四步：交叉比較，比 newStart 和 oldEnd

[點擊] 只要命中其中一步，就執行對應操作，移動索引，然後進入下一輪。不需要四步都比完。
-->

---

# 四種情況的移動邏輯

<div class="mt-6">
  <table class="w-full text-lg">
    <thead>
      <tr class="border-b border-gray-600">
        <th class="text-left py-3 text-gray-300">命中步驟</th>
        <th class="text-left py-3 text-gray-300">含義</th>
        <th class="text-left py-3 text-gray-300">操作</th>
      </tr>
    </thead>
    <tbody>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-cyan-400">步驟一</td>
        <td class="py-3">頭頭相同</td>
        <td class="py-3 text-green-400">不移動，只 patch</td>
      </tr>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-orange-400">步驟二</td>
        <td class="py-3">尾尾相同</td>
        <td class="py-3 text-green-400">不移動，只 patch</td>
      </tr>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-purple-400">步驟三</td>
        <td class="py-3">新尾 = 舊頭</td>
        <td class="py-3 text-yellow-400">舊頭移到舊尾後面</td>
      </tr>
      <tr v-click>
        <td class="py-3 text-pink-400">步驟四</td>
        <td class="py-3">新頭 = 舊尾</td>
        <td class="py-3 text-yellow-400">舊尾移到舊頭前面</td>
      </tr>
    </tbody>
  </table>
</div>

<!--
這四種情況對應不同的處理邏輯，我們來看每一種：

[點擊] 步驟一，頭頭相同，代表這個節點本來就在對的位置，不需要移動，只做 patch 更新內容。

[點擊] 步驟二，尾尾相同，同樣不需要移動，只做 patch。

[點擊] 步驟三，新尾等於舊頭，這代表什麼？代表舊的頭部節點要移到尾部去。所以要把舊頭移到舊尾後面。

[點擊] 步驟四，新頭等於舊尾，代表舊的尾部節點要移到頭部來。所以要把舊尾移到舊頭前面。
-->

---
clicks: 15
---

# 動畫演示

<DiffAnimationDoubleEnded :clicks="$clicks" />

<!--
好，說了這麼多，讓我們用動畫來實際演示一次雙端 Diff 的過程。

舊子節點是 p-1、p-2、p-3、p-4，新子節點是 p-4、p-2、p-1、p-3。

動畫中的連線說明一下：
- 青色虛線代表正在比較頭部
- 橙色虛線代表正在比較尾部或交叉
- 綠色實線代表配對成功

點擊或按空格鍵，跟著動畫一步步看雙端 Diff 是怎麼運作的。
-->

---

# 程式碼結構

<div class="overflow-y-auto max-h-100">

````md magic-move
```js
function patchChildren(n1, n2, container) {
  if (typeof n1.type === 'string') {
    // 省略部分
  } else if (Array.isArray(n2.children)) {
    // 封裝 patchKeyedChildren 函數處理兩組子節點
    patchKeyedChildren(n1, n2, container)
  } else {
    // 省略部分
  }
}

function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children
  const newChildren = n2.children

  // 四個索引
  let oldStartIdx = 0
  let oldEndIdx = oldChildren.length - 1
  let newStartIdx = 0
  let newEndIdx = newChildren.length - 1
}
```

```js {all|2-3|5-9|11-15|17-27}{lines:true}
function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children
  const newChildren = n2.children

  // 四個索引
  let oldStartIdx = 0
  let oldEndIdx = oldChildren.length - 1
  let newStartIdx = 0
  let newEndIdx = newChildren.length - 1

  // 四個節點
  let oldStartVNode = oldChildren[oldStartIdx]
  let oldEndVNode = oldChildren[oldEndIdx]
  let newStartVNode = newChildren[newStartIdx]
  let newEndVNode = newChildren[newEndIdx]

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVNode.key === newStartVNode.key) {
      // 步驟一：頭頭比較
    } else if (oldEndVNode.key === newEndVNode.key) {
      // 步驟二：尾尾比較
    } else if (oldStartVNode.key === newEndVNode.key) {
      // 步驟三：舊頭 vs 新尾
    } else if (oldEndVNode.key === newStartVNode.key) {
      // 步驟四：舊尾 vs 新頭
    }
  }
}
```
````

</div>

<!--
看完動畫，來看程式碼怎麼寫。

[點擊] 首先取得新舊兩組子節點。

[點擊] 接著定義四個索引，分別指向新舊節點的頭部和尾部。

[點擊] 再定義四個節點變數，方便後續比較時使用。

[點擊] 最後在 while 迴圈中進行四步比較，命中任一步就執行對應操作，然後繼續下一輪。
-->

---

# 步驟一、二：頭頭/尾尾相同

<div class="overflow-y-auto max-h-100">

```js {all|1-6|8-13}{lines:true}
// 步驟一：頭頭相同，不需要移動
if (oldStartVNode.key === newStartVNode.key) {
  patch(oldStartVNode, newStartVNode, container)
  oldStartVNode = oldChildren[++oldStartIdx]
  newStartVNode = newChildren[++newStartIdx]
}

// 步驟二：尾尾相同，不需要移動
else if (oldEndVNode.key === newEndVNode.key) {
  patch(oldEndVNode, newEndVNode, container)
  oldEndVNode = oldChildren[--oldEndIdx]
  newEndVNode = newChildren[--newEndIdx]
}
```

</div>

<div v-click class="mt-8 p-4 bg-green-900/20 border-2 border-green-500/40 rounded-lg">
  <div class="text-xl text-green-300">
    <span class="font-bold">關鍵點：</span>頭頭或尾尾相同時，節點位置不變，只需要 patch 更新內容
  </div>
</div>

<!--
先來看步驟一和步驟二，這兩個比較簡單：

[點擊] 步驟一：頭頭相同。呼叫 patch 更新節點內容，然後兩個 start 索引都往後移動一格。

[點擊] 步驟二：尾尾相同。同樣呼叫 patch 更新，然後兩個 end 索引都往前移動一格。

[點擊] 記住關鍵點：頭頭或尾尾相同時，節點位置不需要改變，只需要 patch 更新內容就好。
-->

---

# 步驟三、四：交叉比較

<div class="overflow-y-auto max-h-100">

```js {all|1-7|9-15}{lines:true}
// 步驟三：舊頭 = 新尾，移動到尾部
else if (oldStartVNode.key === newEndVNode.key) {
  patch(oldStartVNode, newEndVNode, container)
  insert(oldStartVNode.el, container, oldEndVNode.el.nextSibling)
  oldStartVNode = oldChildren[++oldStartIdx]
  newEndVNode = newChildren[--newEndIdx]
}

// 步驟四：舊尾 = 新頭，移動到頭部
else if (oldEndVNode.key === newStartVNode.key) {
  patch(oldEndVNode, newStartVNode, container)
  insert(oldEndVNode.el, container, oldStartVNode.el)
  oldEndVNode = oldChildren[--oldEndIdx]
  newStartVNode = newChildren[++newStartIdx]
}
```

</div>

<div v-click class="mt-8 p-4 bg-yellow-900/20 border-2 border-yellow-500/40 rounded-lg">
  <div class="text-xl text-yellow-300">
    <span class="font-bold">關鍵點：</span>交叉比較命中時，需要移動 DOM 節點到對應位置
  </div>
</div>

<!--
再來看步驟三和步驟四，這是交叉比較，比較複雜一點：

[點擊] 步驟三：舊頭等於新尾，說明這個節點要移到尾部去。先 patch 更新內容，然後用 insert 把它移到 oldEnd 的後面。

[點擊] 步驟四：舊尾等於新頭，說明這個節點要移到頭部來。先 patch，然後用 insert 把它移到 oldStart 的前面。

[點擊] 關鍵點：交叉比較命中時，除了 patch 之外，還需要實際移動 DOM 節點到對應位置。
-->

---

# 雙端 Diff 的優勢

<div class="mt-8">
  <div class="text-2xl text-gray-300 mb-6">用之前的例子對比：</div>

  <div class="grid grid-cols-2 gap-8 mb-8">
    <div class="bg-gray-800/50 rounded-lg p-4">
      <div class="text-lg text-gray-400 mb-2">舊：</div>
      <div class="text-xl font-mono">[p-1, p-2, p-3]</div>
    </div>
    <div class="bg-gray-800/50 rounded-lg p-4">
      <div class="text-lg text-gray-400 mb-2">新：</div>
      <div class="text-xl font-mono">[p-3, p-1, p-2]</div>
    </div>
  </div>

  <table class="w-full text-xl">
    <thead>
      <tr class="border-b border-gray-600">
        <th class="text-left py-3 text-gray-300">算法</th>
        <th class="text-left py-3 text-gray-300">移動次數</th>
        <th class="text-left py-3 text-gray-300">移動的節點</th>
      </tr>
    </thead>
    <tbody>
      <tr v-click class="border-b border-gray-700">
        <td class="py-3 text-blue-400">簡單 Diff</td>
        <td class="py-3 text-red-400 font-bold">2 次</td>
        <td class="py-3">移動 p-1, p-2</td>
      </tr>
      <tr v-click>
        <td class="py-3 text-green-400">雙端 Diff</td>
        <td class="py-3 text-green-400 font-bold">1 次</td>
        <td class="py-3">移動 p-3</td>
      </tr>
    </tbody>
  </table>
</div>

<div v-click class="mt-8 text-center text-xl text-yellow-300">
雙端 Diff 能發現「舊尾 = 新頭」的情況，直接把 p-3 移到最前面
</div>

<!--
好，現在讓我們用之前的例子來對比兩種算法。

舊子節點是 p-1、p-2、p-3，新子節點是 p-3、p-1、p-2。

[點擊] 簡單 Diff 需要 2 次移動，移動 p-1 和 p-2。

[點擊] 雙端 Diff 只需要 1 次移動，移動 p-3 就搞定了。

[點擊] 為什麼？因為雙端 Diff 能發現「舊尾等於新頭」的情況，也就是步驟四命中，直接把 p-3 移到最前面。
-->

---
layout: center
---

# 小結

<div class="grid grid-cols-2 gap-8 mt-12">
  <div class="p-6 bg-blue-900/20 border-2 border-blue-500/40 rounded-lg">
    <div class="text-2xl font-bold text-blue-300 mb-4">簡單 Diff</div>
    <ul class="space-y-2 text-gray-300">
      <li>單向遍歷</li>
      <li>用 lastIndex 判斷移動</li>
      <li>移動次數較多</li>
    </ul>
  </div>

  <div class="p-6 bg-green-900/20 border-2 border-green-500/40 rounded-lg">
    <div class="text-2xl font-bold text-green-300 mb-4">雙端 Diff</div>
    <ul class="space-y-2 text-gray-300">
      <li>雙端四步比較</li>
      <li>四種情況對應移動</li>
      <li>移動次數較少</li>
    </ul>
  </div>
</div>

<div v-click class="mt-12 text-center text-2xl text-yellow-300">
下一節：非理想狀況的處理
</div>

<!--
來做個小結。

簡單 Diff 採用單向遍歷，用 lastIndex 判斷是否需要移動，但移動次數可能比較多。

雙端 Diff 採用雙端四步比較，四種情況對應不同的處理策略，能夠減少移動次數。

[點擊] 不過你可能會問：如果四步比較都沒有命中怎麼辦？這就是下一節要討論的：非理想狀況的處理。
-->
