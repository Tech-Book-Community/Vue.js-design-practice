# 第 9 章 & 第 10 章 Q&A 問題集

## 基礎概念題

### Q1: 為什麼需要 key 屬性？沒有 key 會怎樣？

**參考答案：**

沒有 key 時，Vue 只能透過節點的 `type` 來判斷是否可以復用。但當多個節點的 type 相同時（例如一組 `<li>` 元素），就無法區分哪個新節點對應哪個舊節點。

這會導致：
- 只能按照索引順序一一對應
- 即使只是順序改變，也可能觸發不必要的 DOM 更新
- 無法正確復用帶有狀態的組件（如 input 的輸入內容）

有了 key 之後，Vue 可以準確識別每個節點的身份，實現精確的節點復用和移動。

---

### Q2: 簡單 Diff 算法的 `lastIndex` 是什麼？為什麼用它來判斷是否需要移動？

**參考答案：**

`lastIndex` 記錄的是「在舊子節點中，最後一個被訪問到的最大索引值」。

判斷邏輯：
- 遍歷新子節點時，在舊子節點中找到對應的節點
- 如果該舊節點的索引 < lastIndex，說明它在舊順序中排在前面，但在新順序中排在後面，需要移動
- 如果該舊節點的索引 >= lastIndex，更新 lastIndex，不需要移動

核心思想：如果節點在舊陣列中的相對順序與新陣列一致，就不需要移動。lastIndex 幫助我們追蹤這個「遞增序列」。

---

## 進階理解題

### Q3: 為什麼雙端 Diff 比簡單 Diff 的移動次數更少？

**參考答案：**

以 `舊：[p-1, p-2, p-3]` → `新：[p-3, p-1, p-2]` 為例：

**簡單 Diff：**
- 處理 p-3：索引 2 >= lastIndex 0，不移動，lastIndex = 2
- 處理 p-1：索引 0 < lastIndex 2，移動
- 處理 p-2：索引 1 < lastIndex 2，移動
- 結果：2 次移動

**雙端 Diff：**
- 第一輪：舊尾(p-3) = 新頭(p-3)，把 p-3 移到最前面
- 後續：p-1、p-2 位置已經正確
- 結果：1 次移動

雙端 Diff 能從兩端同時比較，更容易發現「只需移動一端」的最優解，而簡單 Diff 只能單向掃描，容易錯過這種優化機會。

---

### Q4: 雙端 Diff 的「四步比較」為什麼要按這個順序？可以換順序嗎？

**參考答案：**

四步比較的順序是：
1. 頭頭比較 (oldStart vs newStart)
2. 尾尾比較 (oldEnd vs newEnd)
3. 舊頭新尾 (oldStart vs newEnd)
4. 舊尾新頭 (oldEnd vs newStart)

這個順序的設計考量：
- 前兩步（頭頭、尾尾）是最理想的情況，不需要移動 DOM，只需要 patch
- 後兩步（交叉比較）需要移動 DOM，開銷較大

順序可以調換，但把「不需要移動」的情況放前面可以盡早命中最優情況，減少比較次數。

---

### Q5: 為什麼非理想狀況下要把找到的舊節點標記為 `undefined`？不標記會怎樣？

**參考答案：**

當四步比較都沒命中時，我們會在舊節點陣列中查找 `newStartVNode`，找到後將其移動到頭部。

如果不標記為 `undefined`：
- 後續的四步比較可能再次命中這個已經移動過的節點
- 會導致同一個節點被處理多次，造成重複移動或錯誤的 DOM 操作

標記為 `undefined` 後：
- 在 while 迴圈開頭會先檢查 `!oldStartVNode` 和 `!oldEndVNode`
- 遇到 undefined 就跳過，確保每個節點只處理一次

---

## 思考題

### Q6: 為什麼 `oldEndIdx < oldStartIdx` 代表舊節點處理完了？

**參考答案：**

雙端 Diff 的索引移動規則：
- `oldStartIdx` 從左往右移動（++）
- `oldEndIdx` 從右往左移動（--）

初始狀態：`oldStartIdx = 0`, `oldEndIdx = length - 1`

每處理完一個節點，對應的索引就往中間靠攏。當 `oldEndIdx < oldStartIdx` 時，代表兩個索引「交叉」了，中間已經沒有未處理的節點。

這就像兩個人從走廊兩端走向中間，當他們相遇並錯過彼此時，代表整個走廊都走過了。

---

### Q7: 循環結束後為什麼要分別處理「添加」和「移除」？這兩種情況能同時發生嗎？

**參考答案：**

**添加條件**：`oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx`
- 舊節點處理完了，新節點還有剩餘

**移除條件**：`newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx`
- 新節點處理完了，舊節點還有剩餘

這兩種情況**不可能同時發生**，因為：
- 如果同時有剩餘，while 迴圈的條件 `oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx` 仍然為真，迴圈不會結束
- 迴圈結束時，至少有一方已經處理完畢（交叉了）

所以用 `if-else if` 而不是兩個獨立的 `if` 是正確的。

---

### Q8: Vue 2 使用雙端 Diff，Vue 3 使用快速 Diff，為什麼要改？

**參考答案：**

雙端 Diff 的時間複雜度是 O(n²)（非理想情況下需要 findIndex 查找），而快速 Diff 引入了「最長遞增子序列」(LIS) 算法，可以：

1. **預處理**：先處理頭尾相同的節點（O(n)）
2. **建立索引表**：用 Map 存儲 key 到索引的映射（O(n)）
3. **計算 LIS**：找出不需要移動的最長序列（O(n log n)）
4. **最小化移動**：只移動不在 LIS 中的節點

整體複雜度降為 O(n log n)，在大規模列表更新時性能提升明顯。

Vue 3 追求更好的性能，所以採用了更高效的快速 Diff 算法。
